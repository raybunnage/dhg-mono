[
  {
    "schema": "pgbouncer",
    "name": "get_auth",
    "arguments": "p_usename text",
    "return_type": "TABLE(username text, password text)",
    "body": "\nBEGIN\n    RAISE WARNING 'PgBouncer auth request: %', p_usename;\n\n    RETURN QUERY\n    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow\n    WHERE usename = p_usename;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "find_mp4_files_in_folder",
    "arguments": "folder_id text",
    "return_type": "TABLE(file_id uuid, file_name text, file_drive_id text, file_web_view_link text, parent_folder_name text, parent_folder_drive_id text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    WITH RECURSIVE folder_tree AS (\n        -- Get all direct MP4 files in the specified folder\n        SELECT \n            sg.id,\n            sg.name,\n            sg.drive_id,\n            sg.web_view_link,\n            p.name as parent_name,\n            p.drive_id as parent_drive_id\n        FROM sources_google sg\n        LEFT JOIN sources_google p ON sg.parent_folder_id = p.drive_id\n        WHERE sg.parent_folder_id = folder_id\n        AND sg.mime_type LIKE '%mp4'\n        \n        UNION ALL\n        \n        -- Recursively search subfolders\n        SELECT \n            sg.id,\n            sg.name,\n            sg.drive_id,\n            sg.web_view_link,\n            p.name,\n            p.drive_id\n        FROM sources_google sg\n        INNER JOIN folder_tree ft ON sg.parent_folder_id = ft.drive_id\n        LEFT JOIN sources_google p ON sg.parent_folder_id = p.drive_id\n        WHERE sg.mime_type LIKE '%mp4'\n    )\n    SELECT * FROM folder_tree;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_encrypt",
    "arguments": "text, bytea",
    "return_type": "bytea",
    "body": "pgp_pub_encrypt_text",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea",
    "return_type": "bytea",
    "body": "pgp_pub_encrypt_bytea",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_encrypt",
    "arguments": "text, bytea, text",
    "return_type": "bytea",
    "body": "pgp_pub_encrypt_text",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "auth",
    "name": "uid",
    "arguments": "",
    "return_type": "uuid",
    "body": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n",
    "description": "Deprecated. Use auth.jwt() -> 'sub' instead.",
    "volatility": "s",
    "owner": "supabase_auth_admin",
    "security_definer": false
  },
  {
    "schema": "auth",
    "name": "role",
    "arguments": "",
    "return_type": "text",
    "body": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n",
    "description": "Deprecated. Use auth.jwt() -> 'role' instead.",
    "volatility": "s",
    "owner": "supabase_auth_admin",
    "security_definer": false
  },
  {
    "schema": "auth",
    "name": "email",
    "arguments": "",
    "return_type": "text",
    "body": "\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n",
    "description": "Deprecated. Use auth.jwt() -> 'email' instead.",
    "volatility": "s",
    "owner": "supabase_auth_admin",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_nil",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_nil",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_ns_dns",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_ns_dns",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_ns_url",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_ns_url",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_ns_oid",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_ns_oid",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_ns_x500",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_ns_x500",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_new_keypair",
    "arguments": "",
    "return_type": "pgsodium.crypto_sign_keypair",
    "body": "pgsodium_crypto_sign_keypair",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea",
    "return_type": "text",
    "body": "pgp_pub_decrypt_text",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_encrypt",
    "arguments": "text, text, text",
    "return_type": "bytea",
    "body": "pgp_sym_encrypt_text",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text, text",
    "return_type": "bytea",
    "body": "pgp_sym_encrypt_bytea",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_decrypt",
    "arguments": "bytea, text",
    "return_type": "text",
    "body": "pgp_sym_decrypt_text",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "body": "pgp_sym_decrypt_bytea",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_decrypt",
    "arguments": "bytea, text, text",
    "return_type": "text",
    "body": "pgp_sym_decrypt_text",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text, text",
    "return_type": "bytea",
    "body": "pgp_sym_decrypt_bytea",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_generate_v1",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_generate_v1",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_generate_v1mc",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_generate_v1mc",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_generate_v3",
    "arguments": "namespace uuid, name text",
    "return_type": "uuid",
    "body": "uuid_generate_v3",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "url_decode",
    "arguments": "data text",
    "return_type": "bytea",
    "body": "\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kx_client_session_keys",
    "arguments": "client_pk bytea, client_sk bytea, server_pk bytea",
    "return_type": "pgsodium.crypto_kx_session",
    "body": "pgsodium_crypto_kx_client_session_keys",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kx_server_session_keys",
    "arguments": "server_pk bytea, server_sk bytea, client_pk bytea",
    "return_type": "pgsodium.crypto_kx_session",
    "body": "pgsodium_crypto_kx_server_session_keys",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_hmacsha512_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgrst_drop_watch",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "update_search_vector",
    "arguments": "",
    "return_type": "trigger",
    "body": "\nBEGIN\n    NEW.search_vector := to_tsvector('english', coalesce(NEW.content, '') || ' ' || coalesce(NEW.subject, ''));\n    RETURN NEW;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_pwhash_saltgen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_pwhash_saltgen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "grant_pg_graphql_access",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n",
    "description": "Grants access to pg_graphql",
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "handle_timestamps",
    "arguments": "",
    "return_type": "trigger",
    "body": "\nBEGIN\n  IF (TG_OP = 'INSERT') THEN\n    NEW.created_at = NOW();\n    NEW.updated_at = NOW();\n  ELSIF (TG_OP = 'UPDATE') THEN\n    NEW.updated_at = NOW();\n  END IF;\n  RETURN NEW;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "list_function_comments",
    "arguments": "",
    "return_type": "TABLE(function_name text, comment_text text, schema_name text, return_type text, argument_types text)",
    "body": "\nbegin\n    return query\n    SELECT \n        p.proname::text as function_name,\n        d.description::text as comment_text,\n        n.nspname::text as schema_name,\n        t.typname::text as return_type,\n        pg_get_function_arguments(p.oid)::text as argument_types\n    FROM \n        pg_proc p\n        LEFT JOIN pg_description d ON p.oid = d.objoid\n        LEFT JOIN pg_namespace n ON p.pronamespace = n.oid\n        LEFT JOIN pg_type t ON p.prorettype = t.oid\n    WHERE \n        n.nspname = 'public'\n    ORDER BY \n        p.proname;\nend;\n",
    "description": "Lists all public functions with their comments, schema, return types, and arguments",
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box_new_seed",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_box_new_seed",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_new_seed",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_sign_new_seed",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "derive_key",
    "arguments": "key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_derive",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "pgsodium_derive",
    "arguments": "key_id bigint, key_len integer DEFAULT 32, context bytea DEFAULT decode('pgsodium'::text, 'escape'::text)",
    "return_type": "bytea",
    "body": "pgsodium_derive",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "randombytes_new_seed",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_randombytes_new_seed",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_secretbox_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box_noncegen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_box_noncegen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_ietf_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "update_processing_timestamps",
    "arguments": "",
    "return_type": "trigger",
    "body": "\nBEGIN\n  IF NEW.processing_status = 'queued' AND OLD.processing_status != 'queued' THEN\n    NEW.queued_at = NOW();\n  ELSIF NEW.processing_status = 'processing' AND OLD.processing_status != 'processing' THEN\n    NEW.processing_started_at = NOW();\n  ELSIF NEW.processing_status = 'completed' AND OLD.processing_status != 'completed' THEN\n    NEW.processing_completed_at = NOW();\n  ELSIF NEW.processing_status = 'failed' AND OLD.processing_status != 'failed' THEN\n    NEW.last_error_at = NOW();\n    NEW.retry_count = COALESCE(OLD.retry_count, 0) + 1;\n  END IF;\n  RETURN NEW;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "body": "\nBEGIN\n   NEW.updated_at = now();\n   RETURN NEW;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "queue_documentation_file_for_processing",
    "arguments": "file_id uuid, priority integer DEFAULT 1",
    "return_type": "uuid",
    "body": "\nDECLARE\n  queue_id UUID;\nBEGIN\n  -- Check if file is already in queue\n  SELECT id INTO queue_id FROM documentation_processing_queue \n  WHERE file_id = queue_documentation_file_for_processing.file_id AND status IN ('pending', 'processing');\n  \n  IF queue_id IS NULL THEN\n    -- Add to queue if not already there\n    INSERT INTO documentation_processing_queue (file_id, priority)\n    VALUES (file_id, priority)\n    RETURNING id INTO queue_id;\n  ELSE\n    -- Update priority if already in queue\n    UPDATE documentation_processing_queue\n    SET priority = GREATEST(priority, queue_documentation_file_for_processing.priority)\n    WHERE id = queue_id;\n  END IF;\n  \n  RETURN queue_id;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_shorthash_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_shorthash_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_generichash_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_generichash_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kdf_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_kdf_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kx_new_keypair",
    "arguments": "",
    "return_type": "pgsodium.crypto_kx_keypair",
    "body": "pgsodium_crypto_kx_keypair",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kx_new_seed",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_kx_new_seed",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kx_seed_new_keypair",
    "arguments": "seed bytea",
    "return_type": "pgsodium.crypto_kx_keypair",
    "body": "pgsodium_crypto_kx_seed_keypair",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_hmacsha256_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box_new_keypair",
    "arguments": "",
    "return_type": "pgsodium.crypto_box_keypair",
    "body": "pgsodium_crypto_box_keypair",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_init",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_sign_init",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_update",
    "arguments": "state bytea, message bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_sign_update",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "randombytes_random",
    "arguments": "",
    "return_type": "integer",
    "body": "pgsodium_randombytes_random",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox_noncegen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_secretbox_noncegen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_noncegen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_ietf_noncegen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "extract_filename",
    "arguments": "file_path text",
    "return_type": "text",
    "body": "\nBEGIN\n  RETURN substring(file_path from '([^/]+)(?:\\.[^.]+)?$');\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretstream_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_secretstream_xchacha20poly1305_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_noncegen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20_noncegen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_cmp",
    "arguments": "text, text",
    "return_type": "boolean",
    "body": "pgsodium_cmp",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_signcrypt_new_keypair",
    "arguments": "",
    "return_type": "pgsodium.crypto_signcrypt_keypair",
    "body": "pgsodium_crypto_signcrypt_keypair",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "sodium_bin2base64",
    "arguments": "bin bytea",
    "return_type": "text",
    "body": "pgsodium_sodium_bin2base64",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "arguments": "message bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_det_encrypt",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "arguments": "ciphertext bytea, additional bytea, key bytea, nonce bytea DEFAULT NULL::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_det_decrypt",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_det_encrypt_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_det_decrypt_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "version",
    "arguments": "",
    "return_type": "text",
    "body": " SELECT extversion FROM pg_extension WHERE extname = 'pgsodium' ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "register_markdown_file",
    "arguments": "p_file_path text, p_title text DEFAULT NULL::text, p_file_hash text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb",
    "return_type": "uuid",
    "body": "\nDECLARE\n  v_file_id UUID;\n  v_title TEXT;\nBEGIN\n  -- Determine title if not provided\n  IF p_title IS NULL THEN\n    v_title := extract_filename(p_file_path);\n  ELSE\n    v_title := p_title;\n  END IF;\n\n  -- Check if file already exists\n  SELECT id INTO v_file_id FROM documentation_files WHERE file_path = p_file_path;\n  \n  IF v_file_id IS NULL THEN\n    -- Insert new file record\n    INSERT INTO documentation_files (\n      file_path,\n      title,\n      last_modified_at,\n      last_indexed_at,\n      file_hash,\n      metadata\n    ) VALUES (\n      p_file_path,\n      v_title,\n      now(),\n      now(),\n      p_file_hash,\n      p_metadata\n    )\n    RETURNING id INTO v_file_id;\n  ELSE\n    -- Update existing file record\n    UPDATE documentation_files\n    SET\n      title = v_title,\n      last_modified_at = now(),\n      last_indexed_at = now(),\n      file_hash = COALESCE(p_file_hash, file_hash),\n      metadata = COALESCE(p_metadata, metadata)\n    WHERE id = v_file_id;\n  END IF;\n  \n  -- Queue for AI processing\n  PERFORM queue_documentation_file_for_processing(v_file_id);\n  \n  RETURN v_file_id;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_noncegen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_det_noncegen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "register_document_section",
    "arguments": "p_file_id uuid, p_heading text, p_level integer, p_position integer, p_anchor_id text, p_summary text DEFAULT NULL::text",
    "return_type": "uuid",
    "body": "\nDECLARE\n  v_section_id UUID;\nBEGIN\n  -- Check if section already exists\n  SELECT id INTO v_section_id \n  FROM documentation_sections \n  WHERE file_id = p_file_id AND anchor_id = p_anchor_id;\n  \n  IF v_section_id IS NULL THEN\n    -- Insert new section\n    INSERT INTO documentation_sections (\n      file_id,\n      heading,\n      level,\n      position,\n      anchor_id,\n      summary\n    ) VALUES (\n      p_file_id,\n      p_heading,\n      p_level,\n      p_position,\n      p_anchor_id,\n      p_summary\n    )\n    RETURNING id INTO v_section_id;\n  ELSE\n    -- Update existing section\n    UPDATE documentation_sections\n    SET\n      heading = p_heading,\n      level = p_level,\n      position = p_position,\n      summary = COALESCE(p_summary, summary)\n    WHERE id = v_section_id;\n  END IF;\n  \n  RETURN v_section_id;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "register_document_relation",
    "arguments": "p_source_id uuid, p_target_id uuid, p_relation_type text",
    "return_type": "uuid",
    "body": "\nDECLARE\n  v_relation_id UUID;\nBEGIN\n  -- Check if relation already exists\n  SELECT id INTO v_relation_id \n  FROM documentation_relations \n  WHERE source_id = p_source_id AND target_id = p_target_id AND relation_type = p_relation_type;\n  \n  IF v_relation_id IS NULL THEN\n    -- Insert new relation\n    INSERT INTO documentation_relations (\n      source_id,\n      target_id,\n      relation_type\n    ) VALUES (\n      p_source_id,\n      p_target_id,\n      p_relation_type\n    )\n    RETURNING id INTO v_relation_id;\n  END IF;\n  \n  RETURN v_relation_id;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "update_document_ai_metadata",
    "arguments": "p_file_id uuid, p_summary text, p_ai_generated_tags text[]",
    "return_type": "void",
    "body": "\nBEGIN\n  UPDATE documentation_files\n  SET\n    summary = p_summary,\n    ai_generated_tags = p_ai_generated_tags\n  WHERE id = p_file_id;\n  \n  -- Mark processing as complete\n  UPDATE documentation_processing_queue\n  SET\n    status = 'completed',\n    updated_at = now()\n  WHERE file_id = p_file_id AND status = 'processing';\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_function_details",
    "arguments": "p_name text",
    "return_type": "TABLE(function_details jsonb, relationships jsonb, history jsonb)",
    "body": "\nBEGIN\n  RETURN QUERY\n  SELECT \n    to_jsonb(f.*) - 'id' as function_details,\n    COALESCE(\n      (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'related_function', fr2.name,\n            'relationship_type', fr.relationship_type,\n            'details', fr.details\n          )\n        )\n        FROM function_relationships fr\n        JOIN function_registry fr2 ON fr.target_function_id = fr2.id\n        WHERE fr.source_function_id = f.id\n      ),\n      '[]'::jsonb\n    ) as relationships,\n    COALESCE(\n      (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'change_type', h.change_type,\n            'changed_at', h.changed_at,\n            'changed_by', h.changed_by,\n            'previous_state', h.previous_state,\n            'new_state', h.new_state,\n            'git_commit_hash', h.git_commit_hash\n          )\n          ORDER BY h.changed_at DESC\n        )\n        FROM function_registry_history h\n        WHERE h.function_id = f.id\n      ),\n      '[]'::jsonb\n    ) as history\n  FROM function_registry f\n  WHERE f.name = p_name;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_next_file_for_processing",
    "arguments": "",
    "return_type": "TABLE(queue_id uuid, file_id uuid, file_path text)",
    "body": "\nBEGIN\n  RETURN QUERY\n  WITH next_file AS (\n    SELECT \n      dpq.id as queue_id,\n      dpq.file_id,\n      df.file_path\n    FROM documentation_processing_queue dpq\n    JOIN documentation_files df ON dpq.file_id = df.id\n    WHERE dpq.status = 'pending'\n    ORDER BY dpq.priority DESC, dpq.created_at ASC\n    LIMIT 1\n    FOR UPDATE SKIP LOCKED\n  )\n  UPDATE documentation_processing_queue dpq\n  SET \n    status = 'processing',\n    attempts = attempts + 1,\n    last_attempt_at = now()\n  FROM next_file\n  WHERE dpq.id = next_file.queue_id\n  RETURNING next_file.queue_id, next_file.file_id, next_file.file_path;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "has_mask",
    "arguments": "role regrole, source_name text",
    "return_type": "boolean",
    "body": "\n  SELECT EXISTS(\n    SELECT 1\n      FROM pg_shseclabel\n     WHERE  objoid = role\n       AND provider = 'pgsodium'\n       AND label ilike 'ACCESS%' || source_name || '%')\n  ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "mask_columns",
    "arguments": "source_relid oid",
    "return_type": "TABLE(attname name, key_id text, key_id_column text, associated_column text, nonce_column text, format_type text)",
    "body": "\n  SELECT\n  a.attname,\n  m.key_id,\n  m.key_id_column,\n  m.associated_column,\n  m.nonce_column,\n  m.format_type\n  FROM pg_attribute a\n  LEFT JOIN  pgsodium.masking_rule m\n  ON m.attrelid = a.attrelid\n  AND m.attname = a.attname\n  WHERE  a.attrelid = source_relid\n  AND    a.attnum > 0 -- exclude ctid, cmin, cmax\n  AND    NOT a.attisdropped\n  ORDER BY a.attnum;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_open",
    "arguments": "signed_message bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_sign_open",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "create_mask_view",
    "arguments": "relid oid, debug boolean DEFAULT false",
    "return_type": "void",
    "body": "\nDECLARE\n  body text;\n  source_name text;\n  view_name text;\n  rule pgsodium.masking_rule;\nBEGIN\n  SELECT DISTINCT(quote_ident(relname)) INTO STRICT view_name\n    FROM pg_class c, pg_seclabel sl\n   WHERE relid = c.oid\n     AND sl.classoid = c.tableoid\n     AND sl.objoid = c.oid;\n\n  source_name := relid::regclass;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS pgsodium_masks.%s;\n    CREATE VIEW pgsodium_masks.%s AS SELECT %s\n    FROM %s;\n    $c$,\n    view_name,\n    view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  body = format(\n    $c$\n    CREATE OR REPLACE FUNCTION pgsodium_masks.%s_encrypt_secret()\n      RETURNS TRIGGER\n      LANGUAGE plpgsql\n      AS $t$\n    BEGIN\n    %s;\n    RETURN new;\n    END;\n    $t$;\n\n    DROP TRIGGER IF EXISTS %s_encrypt_secret_trigger ON %s;\n\n    CREATE TRIGGER %s_encrypt_secret_trigger\n      BEFORE INSERT ON %s\n      FOR EACH ROW\n      EXECUTE FUNCTION pgsodium_masks.%s_encrypt_secret ();\n    $c$,\n    view_name,\n    pgsodium.encrypted_columns(relid),\n    view_name,\n    source_name,\n    view_name,\n    source_name,\n    view_name\n  );\n  if debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_table_info",
    "arguments": "p_table_name text",
    "return_type": "TABLE(column_name text, is_nullable text, data_type text, check_constraint text)",
    "body": "\nbegin\n    return query\n    select \n        c.column_name::text,\n        c.is_nullable::text,\n        c.data_type::text,\n        cc.check_clause::text as check_constraint\n    from information_schema.columns c\n    left join information_schema.constraint_column_usage ccu \n        on ccu.table_name = c.table_name \n        and ccu.column_name = c.column_name\n    left join information_schema.check_constraints cc\n        on cc.constraint_name = ccu.constraint_name\n    where c.table_name = p_table_name\n    and c.table_schema = 'public';\nend;\n",
    "description": "Gets table information including column names, nullability, data types, and check constraints",
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "create_key",
    "arguments": "key_type pgsodium.key_type DEFAULT 'aead-det'::pgsodium.key_type, name text DEFAULT NULL::text, raw_key bytea DEFAULT NULL::bytea, raw_key_nonce bytea DEFAULT NULL::bytea, parent_key uuid DEFAULT NULL::uuid, key_context bytea DEFAULT '\\x7067736f6469756d'::bytea, expires timestamp with time zone DEFAULT NULL::timestamp with time zone, associated_data text DEFAULT ''::text",
    "return_type": "pgsodium.valid_key",
    "body": "\nDECLARE\n  new_key pgsodium.key;\n  valid_key pgsodium.valid_key;\nBEGIN\n  INSERT INTO pgsodium.key (key_id, key_context, key_type, raw_key,\n  raw_key_nonce, parent_key, expires, name, associated_data)\n      VALUES (\n        CASE WHEN raw_key IS NULL THEN\n            NEXTVAL('pgsodium.key_key_id_seq'::REGCLASS)\n        ELSE NULL END,\n        CASE WHEN raw_key IS NULL THEN\n            key_context\n        ELSE NULL END,\n        key_type,\n        raw_key,\n        CASE WHEN raw_key IS NOT NULL THEN\n            COALESCE(raw_key_nonce, pgsodium.crypto_aead_det_noncegen())\n        ELSE NULL END,\n        CASE WHEN parent_key IS NULL and raw_key IS NOT NULL THEN\n            (pgsodium.create_key('aead-det')).id\n        ELSE parent_key END,\n        expires,\n        name,\n        associated_data)\n    RETURNING * INTO new_key;\n  SELECT * INTO valid_key FROM pgsodium.valid_key WHERE id = new_key.id;\n  RETURN valid_key;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "get_key_by_name",
    "arguments": "text",
    "return_type": "pgsodium.valid_key",
    "body": "\n    SELECT * from pgsodium.valid_key WHERE name = $1;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_page_basic_info",
    "arguments": "p_page_path character varying, p_app_name character varying DEFAULT NULL::character varying",
    "return_type": "TABLE(page_id uuid, page_name character varying, page_path character varying, app_name character varying)",
    "body": "\n  SELECT \n    id as page_id,\n    page_name,\n    page_path,\n    app_name\n  FROM \n    public.app_pages\n  WHERE \n    page_path = p_page_path\n    AND (p_app_name IS NULL OR app_name = p_app_name)\n  LIMIT 1;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_page_tables",
    "arguments": "p_page_id uuid",
    "return_type": "TABLE(table_usage_id uuid, table_name character varying, operations character varying[], is_primary boolean)",
    "body": "\n  SELECT \n    id as table_usage_id,\n    table_name,\n    operation_type as operations,\n    is_primary\n  FROM \n    public.page_table_usage\n  WHERE \n    page_id = p_page_id\n  ORDER BY\n    is_primary DESC, table_name;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_page_functions",
    "arguments": "p_page_id uuid",
    "return_type": "TABLE(function_usage_id uuid, function_id uuid, function_name character varying, location character varying, uses_react boolean, ai_prompts jsonb, refactor_candidate boolean, specificity character varying, usage_type character varying)",
    "body": "\n  SELECT \n    pfu.id as function_usage_id,\n    fr.id as function_id,\n    fr.name as function_name,\n    fr.location,\n    fr.uses_react,\n    fr.ai_prompts,\n    fr.refactor_candidate,\n    fr.specificity,\n    pfu.usage_type\n  FROM \n    public.page_function_usage pfu\n  JOIN\n    public.function_registry fr ON pfu.function_id = fr.id\n  WHERE \n    pfu.page_id = p_page_id\n  ORDER BY\n    fr.name;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "quote_assoc",
    "arguments": "text, boolean DEFAULT false",
    "return_type": "text",
    "body": "\n    WITH a AS (SELECT array_agg(CASE WHEN $2 THEN\n                                    'new.' || quote_ident(trim(v))\n                                ELSE quote_ident(trim(v)) END) as r\n               FROM regexp_split_to_table($1, '\\s*,\\s*') as v)\n    SELECT array_to_string(a.r, '::text || ') || '::text' FROM a;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_page_dependencies",
    "arguments": "p_page_id uuid",
    "return_type": "TABLE(dependency_id uuid, dependency_type character varying, dependency_name character varying, details jsonb)",
    "body": "\n  SELECT \n    id as dependency_id,\n    dependency_type,\n    dependency_name,\n    details\n  FROM \n    public.page_dependencies\n  WHERE \n    page_id = p_page_id\n  ORDER BY\n    dependency_type, dependency_name;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_or_create_page",
    "arguments": "p_page_path character varying, p_app_name character varying, p_page_name character varying DEFAULT NULL::character varying",
    "return_type": "uuid",
    "body": "\nDECLARE\n  v_page_id UUID;\n  v_page_name VARCHAR;\nBEGIN\n  -- Set default page name if not provided\n  v_page_name := COALESCE(p_page_name, p_page_path);\n  \n  -- Try to get existing page\n  SELECT id INTO v_page_id\n  FROM public.app_pages\n  WHERE page_path = p_page_path AND app_name = p_app_name;\n  \n  -- Create page if it doesn't exist\n  IF v_page_id IS NULL THEN\n    INSERT INTO public.app_pages (\n      page_name,\n      page_path,\n      app_name\n    )\n    VALUES (\n      v_page_name,\n      p_page_path,\n      p_app_name\n    )\n    RETURNING id INTO v_page_id;\n  END IF;\n  \n  RETURN v_page_id;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "batch_track_usage",
    "arguments": "p_page_id uuid, p_tables jsonb DEFAULT NULL::jsonb, p_functions jsonb DEFAULT NULL::jsonb, p_dependencies jsonb DEFAULT NULL::jsonb",
    "return_type": "boolean",
    "body": "\nDECLARE\n  v_table JSONB;\n  v_function JSONB;\n  v_dependency JSONB;\nBEGIN\n  -- Process tables\n  IF p_tables IS NOT NULL AND jsonb_array_length(p_tables) > 0 THEN\n    FOR v_table IN SELECT * FROM jsonb_array_elements(p_tables)\n    LOOP\n      PERFORM register_table_usage(\n        p_page_id,\n        v_table->>'table_name',\n        (SELECT array_agg(x) FROM jsonb_array_elements_text(v_table->'operations') x),\n        COALESCE((v_table->>'is_primary')::boolean, false)\n      );\n    END LOOP;\n  END IF;\n  \n  -- Process functions\n  IF p_functions IS NOT NULL AND jsonb_array_length(p_functions) > 0 THEN\n    FOR v_function IN SELECT * FROM jsonb_array_elements(p_functions)\n    LOOP\n      PERFORM register_function_usage(\n        p_page_id,\n        (v_function->>'function_id')::uuid,\n        COALESCE(v_function->>'usage_type', 'direct')\n      );\n    END LOOP;\n  END IF;\n  \n  -- Process dependencies\n  IF p_dependencies IS NOT NULL AND jsonb_array_length(p_dependencies) > 0 THEN\n    FOR v_dependency IN SELECT * FROM jsonb_array_elements(p_dependencies)\n    LOOP\n      PERFORM register_dependency(\n        p_page_id,\n        v_dependency->>'dependency_type',\n        v_dependency->>'dependency_name',\n        v_dependency->'details'\n      );\n    END LOOP;\n  END IF;\n  \n  RETURN TRUE;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_seed_new_keypair",
    "arguments": "seed bytea",
    "return_type": "pgsodium.crypto_sign_keypair",
    "body": "pgsodium_crypto_sign_seed_keypair",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kdf_derive_from_key",
    "arguments": "subkey_size integer, subkey_id bigint, context bytea, primary_key uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = primary_key AND key_type = 'kdf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_kdf_derive_from_key(subkey_size, subkey_id, context, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.derive_key(key.key_id, subkey_size, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "get_named_keys",
    "arguments": "filter text DEFAULT '%'::text",
    "return_type": "SETOF pgsodium.valid_key",
    "body": "\n    SELECT * from pgsodium.valid_key vk WHERE vk.name ILIKE filter;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "arguments": "message bytea, additional bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context);\nEND;\n  ",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "arguments": "message bytea, additional bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context);\nEND;\n  ",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_encrypt",
    "arguments": "message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_ietf_encrypt_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "get_key_by_id",
    "arguments": "uuid",
    "return_type": "pgsodium.valid_key",
    "body": "\n    SELECT * from pgsodium.valid_key WHERE id = $1;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "enable_security_label_trigger",
    "arguments": "",
    "return_type": "void",
    "body": "\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update ENABLE;\n  ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "disable_security_label_trigger",
    "arguments": "",
    "return_type": "void",
    "body": "\n    ALTER EVENT TRIGGER pgsodium_trg_mask_update DISABLE;\n  ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "update_mask",
    "arguments": "target oid, debug boolean DEFAULT false",
    "return_type": "void",
    "body": "\nBEGIN\n  PERFORM pgsodium.disable_security_label_trigger();\n  PERFORM pgsodium.create_mask_view(objoid, objsubid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    WHERE sl.objoid = target\n      AND sl.label ILIKE 'ENCRYPT%'\n      AND sl.provider = 'pgsodium';\n  PERFORM pgsodium.enable_security_label_trigger();\n  RETURN;\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_document_type_counts",
    "arguments": "",
    "return_type": "TABLE(mime_type text, count bigint)",
    "body": "\nBEGIN\n  RETURN QUERY\n  SELECT \n    COALESCE(sources_google.mime_type, 'unknown') as mime_type,\n    COUNT(*) as count\n  FROM \n    sources_google\n  WHERE \n    deleted = false\n  GROUP BY \n    sources_google.mime_type\n  ORDER BY \n    count DESC;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_update_agg1",
    "arguments": "state bytea, message bytea",
    "return_type": "bytea",
    "body": "\n SELECT pgsodium.crypto_sign_update(COALESCE(state, pgsodium.crypto_sign_init()), message);\n",
    "description": "Internal helper function for crypto_sign_update_agg(bytea). This\ninitializes state if it has not already been initialized.",
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_update_agg2",
    "arguments": "cur_state bytea, initial_state bytea, message bytea",
    "return_type": "bytea",
    "body": "\n SELECT pgsodium.crypto_sign_update(\n       COALESCE(cur_state, initial_state),\n\t   message)\n",
    "description": "Internal helper function for crypto_sign_update_agg(bytea, bytea). This\ninitializes state to the state passed to the aggregate as a parameter,\nif it has not already been initialized.",
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "encrypted_columns",
    "arguments": "relid oid",
    "return_type": "text",
    "body": "\nDECLARE\n    m RECORD;\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    IF m.key_id IS NULL AND m.key_id_column is NULL THEN\n      CONTINUE;\n    ELSE\n      expression := expression || comma;\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n                  pgsodium.crypto_aead_det_encrypt(\n                    pg_catalog.convert_to(%s, 'utf8'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'base64') END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE\n                        pgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n                %s::uuid,\n                %s\n              ) END END$f$,\n                'new.' || quote_ident(m.attname),\n                'new.' || quote_ident(m.attname),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                'new.' || quote_ident(m.attname),\n                COALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n                COALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                COALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n          );\n      END IF;\n    END IF;\n    comma := E';\\n        ';\n  END LOOP;\n  RETURN expression;\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "decrypted_columns",
    "arguments": "relid oid",
    "return_type": "text",
    "body": "\nDECLARE\n  m RECORD;\n  expression TEXT;\n  comma TEXT;\n  padding text = '        ';\nBEGIN\n  expression := E'\\n';\n  comma := padding;\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n    expression := expression || comma;\n    IF m.key_id IS NULL AND m.key_id_column IS NULL THEN\n      expression := expression || padding || quote_ident(m.attname);\n    ELSE\n      expression := expression || padding || quote_ident(m.attname) || E',\\n';\n      IF m.format_type = 'text' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.convert_from(\n                  pgsodium.crypto_aead_det_decrypt(\n                    pg_catalog.decode(%s, 'base64'),\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ),\n                    'utf8') END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                quote_ident('decrypted_' || m.attname)\n          );\n      ELSIF m.format_type = 'bytea' THEN\n          expression := expression || format(\n            $f$\n            CASE WHEN %s IS NULL THEN NULL ELSE\n                CASE WHEN %s IS NULL THEN NULL ELSE pgsodium.crypto_aead_det_decrypt(\n                    %s::bytea,\n                    pg_catalog.convert_to((%s)::text, 'utf8'),\n                    %s::uuid,\n                    %s\n                  ) END\n                END AS %s$f$,\n                quote_ident(m.attname),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                quote_ident(m.attname),\n                coalesce(pgsodium.quote_assoc(m.associated_columns), quote_literal('')),\n                coalesce(quote_ident(m.key_id_column), quote_literal(m.key_id)),\n                coalesce(quote_ident(m.nonce_column), 'NULL'),\n                'decrypted_' || quote_ident(m.attname)\n          );\n      END IF;\n    END IF;\n    comma := E',       \\n';\n  END LOOP;\n  RETURN expression;\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_encrypt",
    "arguments": "message bytea, additional bytea, nonce bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_ietf_encrypt",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_encrypt",
    "arguments": "message bytea, additional bytea, nonce bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_encrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  ",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_decrypt",
    "arguments": "message bytea, additional bytea, nonce bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_ietf_decrypt",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_decrypt",
    "arguments": "message bytea, additional bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_ietf_decrypt_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_ietf_decrypt",
    "arguments": "message bytea, additional bytea, nonce bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-ietf';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_aead_ietf_decrypt(message, additional, nonce, key.key_id, key.key_context);\nEND;\n  ",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth",
    "arguments": "message bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth",
    "arguments": "message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth",
    "arguments": "message bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth(message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_verify",
    "arguments": "mac bytea, message bytea, key bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_auth_verify",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_verify",
    "arguments": "mac bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_auth_verify_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_verify",
    "arguments": "mac bytea, message bytea, key_uuid uuid",
    "return_type": "boolean",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'auth';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_verify(mac, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_verify(mac, message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box_seed_new_keypair",
    "arguments": "seed bytea",
    "return_type": "pgsodium.crypto_box_keypair",
    "body": "pgsodium_crypto_box_seed_keypair",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box",
    "arguments": "message bytea, nonce bytea, public bytea, secret bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_box",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box_open",
    "arguments": "ciphertext bytea, nonce bytea, public bytea, secret bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_box_open",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box_seal",
    "arguments": "message bytea, public_key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_box_seal",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_box_seal_open",
    "arguments": "ciphertext bytea, public_key bytea, secret_key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_box_seal_open",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_generichash",
    "arguments": "message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_generichash_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_generichash",
    "arguments": "message bytea, key bytea DEFAULT NULL::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_generichash",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_generichash",
    "arguments": "message bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'generichash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_generichash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_generichash(message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_shorthash",
    "arguments": "message bytea, key bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_shorthash_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_shorthash",
    "arguments": "message bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_shorthash",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_shorthash",
    "arguments": "message bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'shorthash';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_shorthash(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_shorthash(message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "sodium_base642bin",
    "arguments": "base64 text",
    "return_type": "bytea",
    "body": "pgsodium_sodium_base642bin",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512",
    "arguments": "message bytea, secret bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_hmacsha512",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512",
    "arguments": "message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_hmacsha512_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512",
    "arguments": "message bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512(message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_verify",
    "arguments": "hash bytea, message bytea, secret bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_auth_hmacsha512_verify",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_verify",
    "arguments": "hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_auth_hmacsha512_verify_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha512_verify",
    "arguments": "signature bytea, message bytea, key_uuid uuid",
    "return_type": "boolean",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha512';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha512_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256",
    "arguments": "message bytea, secret bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_hmacsha256",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256",
    "arguments": "message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_auth_hmacsha256_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256",
    "arguments": "message bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256(message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256(message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_verify",
    "arguments": "hash bytea, message bytea, secret bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_auth_hmacsha256_verify",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_verify",
    "arguments": "hash bytea, message bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_auth_hmacsha256_verify_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_auth_hmacsha256_verify",
    "arguments": "signature bytea, message bytea, key_uuid uuid",
    "return_type": "boolean",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'hmacsha256';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_auth_hmacsha256_verify(signature, message, key.key_id, key.key_context);\nEND;\n\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_kdf_derive_from_key",
    "arguments": "subkey_size bigint, subkey_id bigint, context bytea, primary_key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_kdf_derive_from_key",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_pwhash",
    "arguments": "password bytea, salt bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_pwhash",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_pwhash_str",
    "arguments": "password bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_pwhash_str",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_pwhash_str_verify",
    "arguments": "hashed_password bytea, password bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_pwhash_str_verify",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "randombytes_uniform",
    "arguments": "upper_bound integer",
    "return_type": "integer",
    "body": "pgsodium_randombytes_uniform",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "randombytes_buf",
    "arguments": "size integer",
    "return_type": "bytea",
    "body": "pgsodium_randombytes_buf",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "randombytes_buf_deterministic",
    "arguments": "size integer, seed bytea",
    "return_type": "bytea",
    "body": "pgsodium_randombytes_buf_deterministic",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox",
    "arguments": "message bytea, nonce bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_secretbox",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox",
    "arguments": "message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_secretbox_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox",
    "arguments": "message bytea, nonce bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox(message, nonce, key.key_id, key.key_context);\nEND;\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox_open",
    "arguments": "ciphertext bytea, nonce bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_secretbox_open",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox_open",
    "arguments": "message bytea, nonce bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_secretbox_open_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_secretbox_open",
    "arguments": "message bytea, nonce bytea, key_uuid uuid",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'secretbox';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_secretbox_open(message, nonce, key.decrypted_raw_key);\n  END IF;\n  RETURN pgsodium.crypto_secretbox_open(message, nonce, key.key_id, key.key_context);\nEND;\n",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_hash_sha256",
    "arguments": "message bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_hash_sha256",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_hash_sha512",
    "arguments": "message bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_hash_sha512",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign",
    "arguments": "message bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_sign",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_detached",
    "arguments": "message bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_sign_detached",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_final_create",
    "arguments": "state bytea, key bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_sign_final_create",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_final_verify",
    "arguments": "state bytea, signature bytea, key bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_sign_final_verify",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_sign_verify_detached",
    "arguments": "sig bytea, message bytea, key bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_sign_verify_detached",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_signcrypt_sign_after",
    "arguments": "state bytea, sender_sk bytea, ciphertext bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_signcrypt_sign_after",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_signcrypt_sign_before",
    "arguments": "sender bytea, recipient bytea, sender_sk bytea, recipient_pk bytea, additional bytea",
    "return_type": "pgsodium.crypto_signcrypt_state_key",
    "body": "pgsodium_crypto_signcrypt_sign_before",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_signcrypt_verify_after",
    "arguments": "state bytea, signature bytea, sender_pk bytea, ciphertext bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_signcrypt_verify_after",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_signcrypt_verify_before",
    "arguments": "signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, recipient_sk bytea",
    "return_type": "pgsodium.crypto_signcrypt_state_key",
    "body": "pgsodium_crypto_signcrypt_verify_before",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_signcrypt_verify_public",
    "arguments": "signature bytea, sender bytea, recipient bytea, additional bytea, sender_pk bytea, ciphertext bytea",
    "return_type": "boolean",
    "body": "pgsodium_crypto_signcrypt_verify_public",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20",
    "arguments": "bigint, bytea, bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20",
    "arguments": "bigint, bytea, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor",
    "arguments": "bytea, bytea, bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20_xor",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor",
    "arguments": "bytea, bytea, bigint, context bytea DEFAULT '\\x70676f736469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20_xor_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor_ic",
    "arguments": "bytea, bytea, bigint, bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20_xor_ic",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "crypto_stream_xchacha20_xor_ic",
    "arguments": "bytea, bytea, bigint, bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea",
    "return_type": "bytea",
    "body": "pgsodium_crypto_stream_xchacha20_xor_ic_by_id",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "encrypted_column",
    "arguments": "relid oid, m record",
    "return_type": "text",
    "body": "\nDECLARE\n    expression TEXT;\n    comma TEXT;\nBEGIN\n  expression := '';\n  comma := E'        ';\n  expression := expression || comma;\n  IF m.format_type = 'text' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(%s, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t\t%s::uuid,\n\t\t\t\t%s\n\t\t\t  ),\n\t\t\t\t'base64') END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  ELSIF m.format_type = 'bytea' THEN\n\t  expression := expression || format(\n\t\t$f$%s = CASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN %s IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(%s::bytea, pg_catalog.convert_to((%s)::text, 'utf8'),\n\t\t\t%s::uuid,\n\t\t\t%s\n\t\t  ) END END$f$,\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\t'new.' || quote_ident(m.attname),\n\t\t\tCOALESCE(pgsodium.quote_assoc(m.associated_columns, true), quote_literal('')),\n\t\t\tCOALESCE('new.' || quote_ident(m.key_id_column), quote_literal(m.key_id)),\n\t\t\tCOALESCE('new.' || quote_ident(m.nonce_column), 'NULL')\n\t  );\n  END IF;\n  comma := E';\\n        ';\n  RETURN expression;\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "gen_salt",
    "arguments": "text",
    "return_type": "text",
    "body": "pg_gen_salt",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "gen_salt",
    "arguments": "text, integer",
    "return_type": "text",
    "body": "pg_gen_salt_rounds",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "encrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "body": "pg_encrypt",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "decrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "body": "pg_decrypt",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "encrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "return_type": "bytea",
    "body": "pg_encrypt_iv",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "decrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "return_type": "bytea",
    "body": "pg_decrypt_iv",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "update_masks",
    "arguments": "debug boolean DEFAULT false",
    "return_type": "void",
    "body": "\nBEGIN\n  PERFORM pgsodium.update_mask(objoid, debug)\n    FROM pg_catalog.pg_seclabel sl\n    JOIN pg_catalog.pg_class cl ON (cl.oid = sl.objoid)\n    WHERE label ilike 'ENCRYPT%'\n       AND cl.relowner = session_user::regrole::oid\n       AND provider = 'pgsodium'\n\t   AND objoid::regclass != 'pgsodium.key'::regclass\n\t;\n  RETURN;\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "key_encrypt_secret_raw_key",
    "arguments": "",
    "return_type": "trigger",
    "body": "\n\t\tBEGIN\n\t\t        new.raw_key = CASE WHEN new.raw_key IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.parent_key IS NULL THEN NULL ELSE\n\t\t\t\t\tpgsodium.crypto_aead_det_encrypt(new.raw_key::bytea, pg_catalog.convert_to((new.id::text || new.associated_data::text)::text, 'utf8'),\n\t\t\tnew.parent_key::uuid,\n\t\t\tnew.raw_key_nonce\n\t\t  ) END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "create_mask_view",
    "arguments": "relid oid, subid integer, debug boolean DEFAULT false",
    "return_type": "void",
    "body": "\nDECLARE\n  m record;\n  body text;\n  source_name text;\n  view_owner regrole = session_user;\n  rule pgsodium.masking_rule;\n  privs aclitem[];\n  priv record;\nBEGIN\n  SELECT DISTINCT * INTO STRICT rule FROM pgsodium.masking_rule WHERE attrelid = relid AND attnum = subid;\n\n  source_name := relid::regclass::text;\n\n  BEGIN\n    SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = rule.view_name::regclass::oid;\n  EXCEPTION\n\tWHEN undefined_table THEN\n      SELECT relacl INTO STRICT privs FROM pg_catalog.pg_class WHERE oid = relid;\n  END;\n\n  body = format(\n    $c$\n    DROP VIEW IF EXISTS %1$s;\n    CREATE VIEW %1$s %5$s AS SELECT %2$s\n    FROM %3$s;\n    ALTER VIEW %1$s OWNER TO %4$s;\n    $c$,\n    rule.view_name,\n    pgsodium.decrypted_columns(relid),\n    source_name,\n    view_owner,\n    CASE WHEN rule.security_invoker THEN 'WITH (security_invoker=true)' ELSE '' END\n  );\n  IF debug THEN\n    RAISE NOTICE '%', body;\n  END IF;\n  EXECUTE body;\n\n  FOR priv IN SELECT * FROM pg_catalog.aclexplode(privs) LOOP\n\tbody = format(\n\t  $c$\n\t  GRANT %s ON %s TO %s;\n\t  $c$,\n\t  priv.privilege_type,\n\t  rule.view_name,\n\t  priv.grantee::regrole::text\n\t);\n\tIF debug THEN\n\t  RAISE NOTICE '%', body;\n\tEND IF;\n\tEXECUTE body;\n  END LOOP;\n\n  FOR m IN SELECT * FROM pgsodium.mask_columns where attrelid = relid LOOP\n\tIF m.key_id IS NULL AND m.key_id_column is NULL THEN\n\t  CONTINUE;\n\tELSE\n\t  body = format(\n\t\t$c$\n\t\tDROP FUNCTION IF EXISTS %1$s.\"%2$s_encrypt_secret_%3$s\"() CASCADE;\n\n\t\tCREATE OR REPLACE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\"()\n\t\t  RETURNS TRIGGER\n\t\t  LANGUAGE plpgsql\n\t\t  AS $t$\n\t\tBEGIN\n\t\t%4$s;\n\t\tRETURN new;\n\t\tEND;\n\t\t$t$;\n\n\t\tALTER FUNCTION  %1$s.\"%2$s_encrypt_secret_%3$s\"() OWNER TO %5$s;\n\n\t\tDROP TRIGGER IF EXISTS \"%2$s_encrypt_secret_trigger_%3$s\" ON %6$s;\n\n\t\tCREATE TRIGGER \"%2$s_encrypt_secret_trigger_%3$s\"\n\t\t  BEFORE INSERT OR UPDATE OF \"%3$s\" ON %6$s\n\t\t  FOR EACH ROW\n\t\t  EXECUTE FUNCTION %1$s.\"%2$s_encrypt_secret_%3$s\" ();\n\t\t  $c$,\n\t\trule.relnamespace,\n\t\trule.relname,\n\t\tm.attname,\n\t\tpgsodium.encrypted_column(relid, m),\n\t\tview_owner,\n\t\tsource_name\n\t  );\n\t  if debug THEN\n\t\tRAISE NOTICE '%', body;\n\t  END IF;\n\t  EXECUTE body;\n\tEND IF;\n  END LOOP;\n\n  raise notice 'about to masking role % %', source_name, rule.view_name;\n  PERFORM pgsodium.mask_role(oid::regrole, source_name, rule.view_name)\n  FROM pg_roles WHERE pgsodium.has_mask(oid::regrole, source_name);\n\n  RETURN;\nEND\n  ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "trg_mask_update",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\nDECLARE\n  r record;\nBEGIN\n  IF (SELECT bool_or(in_extension) FROM pg_event_trigger_ddl_commands()) THEN\n    RAISE NOTICE 'skipping pgsodium mask regeneration in extension';\n\tRETURN;\n  END IF;\n\n  FOR r IN\n    SELECT e.*\n    FROM pg_event_trigger_ddl_commands() e\n    WHERE EXISTS (\n      SELECT FROM pg_catalog.pg_class c\n      JOIN pg_catalog.pg_seclabel s ON s.classoid = c.tableoid\n                                   AND s.objoid = c.oid\n      WHERE c.tableoid = e.classid\n        AND e.objid = c.oid\n        AND s.provider = 'pgsodium'\n    )\n  LOOP\n    IF r.object_type in ('table', 'table column')\n    THEN\n      PERFORM pgsodium.update_mask(r.objid);\n    END IF;\n  END LOOP;\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "pgsodium",
    "name": "mask_role",
    "arguments": "masked_role regrole, source_name text, view_name text",
    "return_type": "void",
    "body": "\n    BEGIN\n      EXECUTE format(\n        'GRANT SELECT ON pgsodium.key TO %s',\n        masked_role);\n\n      EXECUTE format(\n        'GRANT pgsodium_keyiduser, pgsodium_keyholder TO %s',\n        masked_role);\n\n      EXECUTE format(\n        'GRANT ALL ON %I TO %s',\n        view_name,\n        masked_role);\n      RETURN;\n    END\n    ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_decrypt",
    "arguments": "message bytea, additional bytea, key_uuid uuid, nonce bytea",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_decrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  ",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_encrypt",
    "arguments": "message bytea, additional bytea, key_uuid uuid, nonce bytea",
    "return_type": "bytea",
    "body": "\nDECLARE\n  key pgsodium.decrypted_key;\nBEGIN\n  SELECT * INTO STRICT key\n    FROM pgsodium.decrypted_key v\n  WHERE id = key_uuid AND key_type = 'aead-det';\n\n  IF key.decrypted_raw_key IS NOT NULL THEN\n    RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.decrypted_raw_key, nonce);\n  END IF;\n  RETURN pgsodium.crypto_aead_det_encrypt(message, additional, key.key_id, key.key_context, nonce);\nEND;\n  ",
    "description": null,
    "volatility": "s",
    "owner": "pgsodium_keymaker",
    "security_definer": true
  },
  {
    "schema": "pgsodium",
    "name": "crypto_aead_det_keygen",
    "arguments": "",
    "return_type": "bytea",
    "body": "pgsodium_crypto_aead_det_keygen",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "vault",
    "name": "secrets_encrypt_secret_secret",
    "arguments": "",
    "return_type": "trigger",
    "body": "\n\t\tBEGIN\n\t\t        new.secret = CASE WHEN new.secret IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(new.secret, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((new.id::text || new.description::text || new.created_at::text || new.updated_at::text)::text, 'utf8'),\n\t\t\t\tnew.key_id::uuid,\n\t\t\t\tnew.nonce\n\t\t\t  ),\n\t\t\t\t'base64') END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "vault",
    "name": "create_secret",
    "arguments": "new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid",
    "return_type": "uuid",
    "body": "\n    INSERT INTO vault.secrets (secret, name, description, key_id)\n    VALUES (\n        new_secret,\n        new_name,\n        new_description,\n        CASE WHEN new_key_id IS NULL THEN (pgsodium.create_key()).id ELSE new_key_id END)\n    RETURNING id;\n    ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "vault",
    "name": "update_secret",
    "arguments": "secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid",
    "return_type": "void",
    "body": "\n\tUPDATE vault.decrypted_secrets s\n    SET\n        secret = CASE WHEN new_secret IS NULL THEN s.decrypted_secret ELSE new_secret END,\n        name = CASE WHEN new_name IS NULL THEN s.name ELSE new_name END,\n        description = CASE WHEN new_description IS NULL THEN s.description ELSE new_description END,\n        key_id = CASE WHEN new_key_id IS NULL THEN s.key_id ELSE new_key_id END,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE s.id = secret_id\n    ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "generate_table_documentation",
    "arguments": "p_table_name text",
    "return_type": "text",
    "body": "\nDECLARE\n    field_info text := '';\n    constraint_info text := '';\n    foreign_key_info text := '';\n    trigger_info text := '';\n    sql text;\n    field RECORD;  -- Declare field as RECORD\n    constr RECORD;  -- Renamed from constraint to constr\n    fk RECORD;  -- Declare foreign key as RECORD\n    trigger RECORD;  -- Declare trigger as RECORD\nBEGIN\n    -- Gather field information\n    sql := format('SELECT column_name, data_type, is_nullable, column_default \n                   FROM information_schema.columns \n                   WHERE table_name = %L', p_table_name);\n    FOR field IN EXECUTE sql LOOP\n        field_info := field_info || format('Field: %s, Type: %s, Nullable: %s, Default: %s%s',\n            field.column_name, field.data_type, field.is_nullable, COALESCE(field.column_default, 'None'), E'\\n');\n    END LOOP;\n\n    -- Gather constraint information\n    sql := format('SELECT conname, contype \n                   FROM pg_constraint \n                   WHERE conrelid = %L::regclass', p_table_name);\n    FOR constr IN EXECUTE sql LOOP\n        constraint_info := constraint_info || format('Constraint: %s, Type: %s%s',\n            constr.conname, \n            CASE constr.contype\n                WHEN 'p' THEN 'Primary Key'\n                WHEN 'u' THEN 'Unique'\n                WHEN 'f' THEN 'Foreign Key'\n                WHEN 'c' THEN 'Check'\n                ELSE 'Other'\n            END, E'\\n');\n    END LOOP;\n\n    -- Gather foreign key information\n    sql := format('SELECT conname, confrelid::regclass AS referenced_table \n                   FROM pg_constraint \n                   WHERE conrelid = %L::regclass AND contype = ''f''', p_table_name);\n    FOR fk IN EXECUTE sql LOOP\n        foreign_key_info := foreign_key_info || format('Foreign Key: %s, References: %s%s',\n            fk.conname, fk.referenced_table, E'\\n');\n    END LOOP;\n\n    -- Gather trigger information\n    sql := format('SELECT tgname \n                   FROM pg_trigger \n                   WHERE tgrelid = %L::regclass', p_table_name);\n    FOR trigger IN EXECUTE sql LOOP\n        trigger_info := trigger_info || format('Trigger: %s%s', trigger.tgname, E'\\n');\n    END LOOP;\n\n    -- Combine all information\n    RETURN 'Fields:\\n' || field_info || \n           'Constraints:\\n' || constraint_info || \n           'Foreign Keys:\\n' || foreign_key_info || \n           'Triggers:\\n' || trigger_info;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_generate_v4",
    "arguments": "",
    "return_type": "uuid",
    "body": "uuid_generate_v4",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "uuid_generate_v5",
    "arguments": "namespace uuid, name text",
    "return_type": "uuid",
    "body": "uuid_generate_v5",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "digest",
    "arguments": "text, text",
    "return_type": "bytea",
    "body": "pg_digest",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "digest",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "body": "pg_digest",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "hmac",
    "arguments": "text, text, text",
    "return_type": "bytea",
    "body": "pg_hmac",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "hmac",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "body": "pg_hmac",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "crypt",
    "arguments": "text, text",
    "return_type": "text",
    "body": "pg_crypt",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "gen_random_bytes",
    "arguments": "integer",
    "return_type": "bytea",
    "body": "pg_random_bytes",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "gen_random_uuid",
    "arguments": "",
    "return_type": "uuid",
    "body": "pg_random_uuid",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_encrypt",
    "arguments": "text, text",
    "return_type": "bytea",
    "body": "pgp_sym_encrypt_text",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "body": "pgp_sym_encrypt_bytea",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "body": "pgp_pub_encrypt_bytea",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea",
    "return_type": "bytea",
    "body": "pgp_pub_decrypt_bytea",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "text",
    "body": "pgp_pub_decrypt_text",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "body": "pgp_pub_decrypt_bytea",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text, text",
    "return_type": "text",
    "body": "pgp_pub_decrypt_text",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text, text",
    "return_type": "bytea",
    "body": "pgp_pub_decrypt_bytea",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_key_id",
    "arguments": "bytea",
    "return_type": "text",
    "body": "pgp_key_id_w",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "armor",
    "arguments": "bytea",
    "return_type": "text",
    "body": "pg_armor",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "armor",
    "arguments": "bytea, text[], text[]",
    "return_type": "text",
    "body": "pg_armor",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "dearmor",
    "arguments": "text",
    "return_type": "bytea",
    "body": "pg_dearmor",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgp_armor_headers",
    "arguments": "text, OUT key text, OUT value text",
    "return_type": "SETOF record",
    "body": "pgp_armor_headers",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "url_encode",
    "arguments": "data bytea",
    "return_type": "text",
    "body": "\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "algorithm_sign",
    "arguments": "signables text, secret text, algorithm text",
    "return_type": "text",
    "body": "\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pg_stat_statements_reset",
    "arguments": "userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0",
    "return_type": "void",
    "body": "pg_stat_statements_reset_1_7",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pg_stat_statements_info",
    "arguments": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
    "return_type": "record",
    "body": "pg_stat_statements_info",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pg_stat_statements",
    "arguments": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision",
    "return_type": "SETOF record",
    "body": "pg_stat_statements_1_10",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "sign",
    "arguments": "payload json, secret text, algorithm text DEFAULT 'HS256'::text",
    "return_type": "text",
    "body": "\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "try_cast_double",
    "arguments": "inp text",
    "return_type": "double precision",
    "body": "\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "verify",
    "arguments": "token text, secret text, algorithm text DEFAULT 'HS256'::text",
    "return_type": "TABLE(header json, payload json, valid boolean)",
    "body": "\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n",
    "description": null,
    "volatility": "i",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "pgrst_ddl_watch",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "graphql",
    "name": "increment_schema_version",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\n  BEGIN\n    perform pg_catalog.nextval('graphql.seq_schema_version');\n  END;\n  ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "extensions",
    "name": "set_graphql_placeholder",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n",
    "description": "Reintroduces placeholder function for graphql_public.graphql",
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "graphql",
    "name": "comment_directive",
    "arguments": "comment_ text",
    "return_type": "jsonb",
    "body": "\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "graphql_public",
    "name": "graphql",
    "arguments": "\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb",
    "return_type": "jsonb",
    "body": "\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "graphql",
    "name": "_internal_resolve",
    "arguments": "query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb",
    "return_type": "jsonb",
    "body": "resolve_wrapper",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "graphql",
    "name": "exception",
    "arguments": "message text",
    "return_type": "text",
    "body": "\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "graphql",
    "name": "get_schema_version",
    "arguments": "",
    "return_type": "integer",
    "body": "\n    select last_value from graphql.seq_schema_version;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": true
  },
  {
    "schema": "graphql",
    "name": "resolve",
    "arguments": "query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb",
    "return_type": "jsonb",
    "body": "\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "grant_pg_cron_access",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n",
    "description": "Grants access to pg_cron",
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "analyze_foreign_keys",
    "arguments": "p_table_name text",
    "return_type": "TABLE(column_name text, potential_reference_table text, potential_reference_column text, match_percentage numeric)",
    "body": "\nBEGIN\n    RETURN QUERY\n    WITH column_values AS (\n        SELECT \n            a.attname as column_name,\n            t2.relname as ref_table,\n            a2.attname as ref_column,\n            count(distinct c1.value) as distinct_values,\n            count(distinct c2.value) as matching_values\n        FROM pg_attribute a\n        JOIN pg_class t ON a.attrelid = t.oid\n        CROSS JOIN pg_class t2\n        JOIN pg_attribute a2 ON a2.attrelid = t2.oid\n        LEFT JOIN LATERAL (\n            SELECT DISTINCT cast(value as text) as value \n            FROM (SELECT (unnest(array_agg(row_to_json->>a.attname)))::text as value \n                  FROM (SELECT row_to_json(t) FROM ONLY pg_catalog.pg_class WHERE relname = p_table_name) x) y\n        ) c1 ON true\n        LEFT JOIN LATERAL (\n            SELECT DISTINCT cast(value as text) as value \n            FROM (SELECT (unnest(array_agg(row_to_json->>a2.attname)))::text as value \n                  FROM (SELECT row_to_json(t2) FROM ONLY pg_catalog.pg_class WHERE relname = t2.relname) x) y\n        ) c2 ON c1.value = c2.value\n        WHERE t.relname = p_table_name \n        AND t2.relname != p_table_name\n        AND a.attnum > 0 \n        AND a2.attnum > 0\n        AND NOT a.attisdropped\n        AND NOT a2.attisdropped\n        GROUP BY a.attname, t2.relname, a2.attname\n        HAVING count(distinct c1.value) > 0\n    )\n    SELECT \n        column_name,\n        ref_table,\n        ref_column,\n        (matching_values::numeric / distinct_values::numeric) * 100 as match_percentage\n    FROM column_values\n    WHERE matching_values::numeric / distinct_values::numeric > 0.8\n    ORDER BY match_percentage DESC;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "analyze_default_values",
    "arguments": "p_table_name text",
    "return_type": "TABLE(column_name text, data_type text, current_default text, suggested_default text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        a.attname,\n        pg_catalog.format_type(a.atttypid, a.atttypmod) as data_type,\n        COALESCE(pg_get_expr(d.adbin, d.adrelid), '') as current_default,\n        CASE \n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE '%timestamp%' \n                THEN 'CURRENT_TIMESTAMP'\n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) = 'boolean' \n                THEN 'false'\n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) = 'integer' \n                THEN '0'\n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) = 'text' \n                THEN ''''\n            ELSE 'No suggestion'\n        END as suggested_default\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef d ON a.attrelid = d.adrelid AND a.attnum = d.adnum\n    JOIN pg_class t ON a.attrelid = t.oid\n    WHERE t.relname = p_table_name \n    AND a.attnum > 0 \n    AND NOT a.attisdropped;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "sanitize_command",
    "arguments": "command_text text",
    "return_type": "text",
    "body": "\nDECLARE\n  sanitized TEXT := command_text;\n  pattern RECORD;\nBEGIN\n  FOR pattern IN SELECT * FROM command_patterns WHERE is_active = TRUE\n  LOOP\n    sanitized := regexp_replace(sanitized, pattern.pattern, pattern.replacement, 'g');\n  END LOOP;\n  \n  RETURN sanitized;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_most_used_commands",
    "arguments": "time_period interval DEFAULT '30 days'::interval, limit_count integer DEFAULT 10",
    "return_type": "TABLE(command_text text, category_name text, usage_count bigint, success_rate numeric)",
    "body": "\n  SELECT \n    ch.sanitized_command,\n    cc.name AS category_name,\n    COUNT(*) AS usage_count,\n    ROUND(SUM(CASE WHEN ch.success THEN 1 ELSE 0 END)::NUMERIC / COUNT(*) * 100, 2) AS success_rate\n  FROM command_history ch\n  JOIN command_categories cc ON ch.category_id = cc.id\n  WHERE ch.executed_at > NOW() - time_period\n  GROUP BY ch.sanitized_command, cc.name\n  ORDER BY usage_count DESC\n  LIMIT limit_count;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_command_usage_by_category",
    "arguments": "time_period interval DEFAULT '30 days'::interval",
    "return_type": "TABLE(category_name text, usage_count bigint, success_rate numeric)",
    "body": "\n  SELECT \n    cc.name AS category_name,\n    COUNT(*) AS usage_count,\n    ROUND(SUM(CASE WHEN ch.success THEN 1 ELSE 0 END)::NUMERIC / COUNT(*) * 100, 2) AS success_rate\n  FROM command_history ch\n  JOIN command_categories cc ON ch.category_id = cc.id\n  WHERE ch.executed_at > NOW() - time_period\n  GROUP BY cc.name\n  ORDER BY usage_count DESC;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_command_history",
    "arguments": "category_filter text DEFAULT NULL::text, success_filter boolean DEFAULT NULL::boolean, search_term text DEFAULT NULL::text, page_size integer DEFAULT 20, page_number integer DEFAULT 1",
    "return_type": "TABLE(id uuid, command_text text, sanitized_command text, category_name text, executed_at timestamp with time zone, duration_ms integer, exit_code integer, success boolean, notes text, tags text[])",
    "body": "\n  SELECT \n    ch.id,\n    ch.command_text,\n    ch.sanitized_command,\n    cc.name AS category_name,\n    ch.executed_at,\n    ch.duration_ms,\n    ch.exit_code,\n    ch.success,\n    ch.notes,\n    ch.tags\n  FROM command_history ch\n  JOIN command_categories cc ON ch.category_id = cc.id\n  WHERE \n    (category_filter IS NULL OR cc.name = category_filter) AND\n    (success_filter IS NULL OR ch.success = success_filter) AND\n    (search_term IS NULL OR \n     ch.sanitized_command ILIKE '%' || search_term || '%' OR\n     ch.notes ILIKE '%' || search_term || '%')\n  ORDER BY ch.executed_at DESC\n  LIMIT page_size\n  OFFSET (page_number - 1) * page_size;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "increment_favorite_command_usage",
    "arguments": "favorite_id uuid",
    "return_type": "void",
    "body": "\nBEGIN\n  UPDATE favorite_commands\n  SET \n    usage_count = usage_count + 1,\n    last_used_at = NOW()\n  WHERE id = favorite_id;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "analyze_table_constraints",
    "arguments": "p_table_name text",
    "return_type": "text",
    "body": "\nDECLARE\n    report text := '';\n    unique_rec record;\nBEGIN\n    -- Initialize report\n    report := 'Table Analysis Report for ' || p_table_name || E'\\n\\n';\n    \n    -- Unique constraints analysis\n    report := report || 'Potential Unique Constraints:' || E'\\n';\n    FOR unique_rec IN SELECT * FROM analyze_unique_constraints(p_table_name) LOOP\n        report := report || format('  Column: %s (Distinct ratio: %s%%) - %s', \n            unique_rec.column_name, \n            round(unique_rec.distinct_ratio * 100, 2)::text, \n            unique_rec.recommendation) || E'\\n';\n    END LOOP;\n    \n    RETURN report;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "analyze_unique_constraints",
    "arguments": "p_table_name text",
    "return_type": "TABLE(column_name text, distinct_ratio numeric, recommendation text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    WITH column_stats AS (\n        SELECT \n            a.attname,\n            pg_stats.n_distinct,\n            pg_stats.null_frac,\n            (SELECT count(*) FROM pg_catalog.pg_class c WHERE c.relname = p_table_name) as total_rows\n        FROM pg_attribute a\n        JOIN pg_class t ON a.attrelid = t.oid\n        LEFT JOIN pg_stats ON t.relname = pg_stats.tablename AND a.attname = pg_stats.attname\n        WHERE t.relname = p_table_name AND a.attnum > 0 AND NOT a.attisdropped\n    )\n    SELECT \n        attname::text,\n        COALESCE(\n            CASE \n                WHEN n_distinct < 0 THEN abs(n_distinct)\n                WHEN n_distinct > 0 THEN n_distinct / total_rows::numeric\n                ELSE 0\n            END,\n            0\n        )::numeric,\n        (CASE \n            WHEN n_distinct < 0 AND abs(n_distinct) > 0.95 THEN 'Highly recommended for UNIQUE constraint'\n            WHEN n_distinct > 0 AND (n_distinct / total_rows::numeric) > 0.95 THEN 'Consider UNIQUE constraint'\n            ELSE 'Not recommended for UNIQUE constraint'\n        END)::text\n    FROM column_stats;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "export_all_functions_to_json",
    "arguments": "",
    "return_type": "json",
    "body": "\nDECLARE\n    result json;\nBEGIN\n    WITH function_info AS (\n        SELECT\n            n.nspname AS schema_name,\n            p.proname AS function_name,\n            pg_get_function_arguments(p.oid) AS arguments,\n            CASE\n                WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN 'trigger'\n                ELSE pg_get_function_result(p.oid)\n            END AS return_type,\n            p.prosrc AS function_body,\n            obj_description(p.oid, 'pg_proc') AS description,\n            p.provolatile AS volatility,\n            pg_catalog.pg_get_userbyid(p.proowner) AS owner,\n            p.prosecdef AS security_definer\n        FROM\n            pg_catalog.pg_proc p\n            INNER JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n        WHERE\n            n.nspname NOT IN ('pg_catalog', 'information_schema')\n            AND p.prokind = 'f'  -- Only regular functions, not aggregates or procedures\n    )\n    SELECT json_agg(\n        json_build_object(\n            'schema', schema_name,\n            'name', function_name,\n            'arguments', arguments,\n            'return_type', return_type,\n            'body', function_body,\n            'description', description,\n            'volatility', volatility,\n            'owner', owner,\n            'security_definer', security_definer\n        )\n    ) INTO result\n    FROM function_info;\n    \n    RETURN COALESCE(result, '[]'::json);\nEND;\n",
    "description": "Exports all PostgreSQL functions in the database to a JSON format, including their definitions, arguments, return types, and other metadata.",
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "generate_unique_constraints_sql",
    "arguments": "p_table_name text",
    "return_type": "text",
    "body": "\nDECLARE\n    unique_rec RECORD;\n    sql_statements text := '';\nBEGIN\n    -- Loop through the unique constraints analysis\n    FOR unique_rec IN SELECT * FROM analyze_unique_constraints(p_table_name) LOOP\n        IF unique_rec.recommendation LIKE 'Highly recommended for UNIQUE constraint' OR\n           unique_rec.recommendation LIKE 'Consider UNIQUE constraint' THEN\n            sql_statements := sql_statements || format('ALTER TABLE %I ADD CONSTRAINT unique_%I UNIQUE (%I);%s', \n                p_table_name, \n                unique_rec.column_name, \n                unique_rec.column_name, \n                E'\\n');\n        END IF;\n    END LOOP;\n\n    -- Return the generated SQL statements\n    RETURN sql_statements;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "find_orphaned_user_ids",
    "arguments": "",
    "return_type": "TABLE(table_name text, column_name text, orphaned_user_id uuid, row_count bigint)",
    "body": "\nBEGIN\n    FOR table_name, column_name IN\n        SELECT t.table_schema || '.' || t.table_name, c.column_name\n        FROM information_schema.columns c\n        JOIN information_schema.tables t \n            ON c.table_name = t.table_name \n            AND c.table_schema = t.table_schema\n        WHERE c.column_name = 'user_id'\n        AND t.table_schema = 'public'\n    LOOP\n        RETURN QUERY EXECUTE format(\n            'SELECT %L::text, %L::text, user_id::uuid, COUNT(*)::bigint ' ||\n            'FROM %s ' ||\n            'WHERE user_id IS NOT NULL ' ||\n            'AND NOT EXISTS (SELECT 1 FROM auth.users WHERE id = user_id) ' ||\n            'GROUP BY user_id',\n            table_name,\n            column_name,\n            table_name\n        );\n    END LOOP;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "export_functions_audit",
    "arguments": "",
    "return_type": "json",
    "body": "\nDECLARE\n  all_functions json;\nBEGIN\n  -- Get basic function information in a simple SQL statement\n  CREATE TEMP TABLE function_data AS\n  SELECT \n    n.nspname AS schema_name,\n    p.proname AS function_name,\n    pg_get_function_arguments(p.oid) AS parameters,\n    CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END || \n      pg_catalog.format_type(p.prorettype, NULL) AS return_type,\n    CASE p.provolatile\n      WHEN 'i' THEN 'IMMUTABLE'\n      WHEN 's' THEN 'STABLE'\n      WHEN 'v' THEN 'VOLATILE'\n    END AS volatility,\n    p.prosecdef AS is_security_definer,\n    obj_description(p.oid, 'pg_proc') AS description,\n    p.proowner::regrole::text AS owner,\n    COALESCE(pg_stat_get_function_calls(p.oid), 0) AS call_count,\n    COALESCE(round(pg_stat_get_function_total_time(p.oid)::numeric, 2), 0) AS total_time_ms,\n    pg_get_functiondef(p.oid) AS full_definition\n  FROM \n    pg_proc p\n  JOIN \n    pg_namespace n ON p.pronamespace = n.oid\n  WHERE \n    n.nspname = 'public';\n\n  -- Add trigger info in a separate step\n  ALTER TABLE function_data ADD COLUMN trigger_count int DEFAULT 0;\n  ALTER TABLE function_data ADD COLUMN used_by_tables text[] DEFAULT '{}';\n  ALTER TABLE function_data ADD COLUMN bound_triggers text[] DEFAULT '{}';\n  \n  -- Update with trigger info\n  WITH trigger_data AS (\n    SELECT \n      p.proname AS function_name,\n      COUNT(*) AS trigger_count,\n      array_agg(DISTINCT t.tgrelid::regclass::text) AS tables,\n      array_agg(DISTINCT t.tgname::text) AS trigger_names\n    FROM \n      pg_trigger t\n    JOIN \n      pg_proc p ON t.tgfoid = p.oid\n    WHERE \n      p.pronamespace = 'public'::regnamespace\n    GROUP BY \n      p.proname\n  )\n  UPDATE function_data fd\n  SET \n    trigger_count = td.trigger_count,\n    used_by_tables = td.tables,\n    bound_triggers = td.trigger_names\n  FROM \n    trigger_data td\n  WHERE \n    fd.function_name = td.function_name;\n    \n  -- Add usage status and score\n  ALTER TABLE function_data ADD COLUMN usage_status text;\n  ALTER TABLE function_data ADD COLUMN usage_score int;\n  \n  UPDATE function_data\n  SET \n    usage_status = \n      CASE \n        WHEN call_count > 100 OR trigger_count > 0 THEN 'ACTIVE'\n        WHEN call_count > 0 THEN 'USED'\n        WHEN function_name LIKE '%get_%' OR \n             function_name LIKE '%find_%' OR\n             function_name LIKE '%check_%' OR\n             function_name LIKE '%validate_%' THEN 'LIKELY USED'\n        ELSE 'POTENTIALLY UNUSED'\n      END,\n    usage_score = \n      CASE WHEN call_count > 0 THEN 100 ELSE 0 END +\n      CASE WHEN trigger_count > 0 THEN 100 ELSE 0 END +\n      CASE WHEN is_security_definer THEN 30 ELSE 0 END +\n      CASE WHEN volatility = 'IMMUTABLE' THEN 10 \n           WHEN volatility = 'STABLE' THEN 20\n           ELSE 30 END;\n  \n  -- Get the final JSON result\n  SELECT json_agg(row_to_json(fd))\n  INTO all_functions\n  FROM (\n    SELECT * FROM function_data\n    ORDER BY \n      CASE \n        WHEN usage_status = 'ACTIVE' THEN 3\n        WHEN usage_status = 'USED' THEN 2\n        WHEN usage_status = 'LIKELY USED' THEN 1\n        ELSE 0\n      END DESC, \n      function_name\n  ) fd;\n  \n  -- Clean up\n  DROP TABLE function_data;\n  \n  RETURN all_functions;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_table_columns_plus",
    "arguments": "p_table_name text",
    "return_type": "TABLE(ordinal_position integer, column_name text, data_type text, is_nullable text, column_default text, is_unique text, unique_constraint_name text, foreign_key text, trigger_name text, check_constraint text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    WITH base_columns AS (\n        SELECT DISTINCT\n            c.ordinal_position::integer,\n            c.column_name,\n            c.data_type,\n            c.is_nullable,\n            c.column_default\n        FROM \n            information_schema.columns c\n        WHERE \n            c.table_schema = 'public' \n            AND c.table_name = p_table_name\n    ),\n    unique_constraints AS (\n        SELECT DISTINCT\n            kcu.column_name,\n            'YES' as is_unique,\n            tc.constraint_name as unique_constraint_name\n        FROM \n            information_schema.key_column_usage kcu \n        JOIN \n            information_schema.table_constraints tc \n            ON kcu.constraint_name = tc.constraint_name \n            AND kcu.table_schema = tc.table_schema\n        WHERE \n            kcu.table_schema = 'public' \n            AND kcu.table_name = p_table_name\n            AND tc.constraint_type IN ('UNIQUE', 'PRIMARY KEY')\n    ),\n    foreign_keys AS (\n        SELECT DISTINCT\n            kcu.column_name,\n            fk.constraint_name as foreign_key\n        FROM \n            information_schema.key_column_usage kcu \n        JOIN \n            information_schema.table_constraints tc \n            ON kcu.constraint_name = tc.constraint_name \n        JOIN \n            information_schema.referential_constraints rc \n            ON tc.constraint_name = rc.constraint_name \n        JOIN \n            information_schema.table_constraints fk \n            ON rc.unique_constraint_name = fk.constraint_name \n        WHERE \n            kcu.table_schema = 'public' \n            AND kcu.table_name = p_table_name\n    ),\n    triggers AS (\n        SELECT DISTINCT\n            t.tgname as table_trigger_name\n        FROM \n            pg_trigger t \n        WHERE \n            t.tgrelid = (SELECT oid FROM pg_class WHERE relname = p_table_name AND relnamespace = 'public'::regnamespace)\n    ),\n    check_constraints AS (\n        SELECT \n            conname AS constraint_name,\n            pg_get_constraintdef(oid) AS constraint_definition\n        FROM \n            pg_constraint\n        WHERE \n            conrelid = (p_table_name::regclass)\n            AND contype = 'c'\n    ),\n    combined_checks AS (\n        SELECT string_agg(\n            constraint_name || ': ' || constraint_definition, \n            '; '\n        ) as all_checks\n        FROM check_constraints\n    )\n    SELECT \n        bc.ordinal_position,\n        bc.column_name::text,\n        bc.data_type::text,\n        bc.is_nullable::text,\n        bc.column_default::text,\n        COALESCE(uc.is_unique, 'NO')::text as is_unique,\n        uc.unique_constraint_name::text,\n        fk.foreign_key::text,\n        (SELECT table_trigger_name::text FROM triggers LIMIT 1) as trigger_name,\n        (SELECT all_checks FROM combined_checks)::text as check_constraint\n    FROM \n        base_columns bc\n        LEFT JOIN unique_constraints uc ON bc.column_name = uc.column_name\n        LEFT JOIN foreign_keys fk ON bc.column_name = fk.column_name\n    ORDER BY \n        bc.ordinal_position;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "check_user_id_foreign_keys",
    "arguments": "",
    "return_type": "TABLE(table_name text, has_user_id boolean, has_proper_fk boolean, constraint_name text, deletion_rule text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    WITH tables_with_user_id AS (\n        SELECT \n            t.table_schema || '.' || t.table_name as table_name,\n            true as has_user_id\n        FROM information_schema.columns c\n        JOIN information_schema.tables t \n            ON c.table_name = t.table_name \n            AND c.table_schema = t.table_schema\n        WHERE c.column_name = 'user_id'\n        AND t.table_schema = 'public'\n    ),\n    foreign_keys AS (\n        SELECT \n            tc.table_schema || '.' || tc.table_name as table_name,\n            tc.constraint_name::text,\n            rc.delete_rule::text\n        FROM information_schema.table_constraints tc\n        JOIN information_schema.key_column_usage kcu \n            ON tc.constraint_name = kcu.constraint_name\n        JOIN information_schema.referential_constraints rc \n            ON tc.constraint_name = rc.constraint_name\n        WHERE kcu.column_name = 'user_id'\n        AND tc.constraint_type = 'FOREIGN KEY'\n    )\n    SELECT \n        t.table_name,\n        true as has_user_id,\n        COALESCE(fk.constraint_name IS NOT NULL, false) as has_proper_fk,\n        COALESCE(fk.constraint_name, 'No Foreign Key')::text as constraint_name,\n        COALESCE(fk.delete_rule, 'No Rule')::text as deletion_rule\n    FROM tables_with_user_id t\n    LEFT JOIN foreign_keys fk ON t.table_name = fk.table_name;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "table_exists",
    "arguments": "p_schema_name text, p_table_name text",
    "return_type": "boolean",
    "body": "\nDECLARE\n  exists_val boolean;\nBEGIN\n  SELECT EXISTS (\n    SELECT FROM information_schema.tables \n    WHERE table_schema = p_schema_name AND table_name = p_table_name\n  ) INTO exists_val;\n  RETURN exists_val;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_foreign_key_info",
    "arguments": "p_constraint_name text",
    "return_type": "TABLE(table_schema text, constraint_name text, table_name text, column_name text, foreign_table_schema text, foreign_table_name text, foreign_column_name text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT\n        tc.table_schema::text, \n        tc.constraint_name::text, \n        tc.table_name::text, \n        kcu.column_name::text, \n        ccu.table_schema::text AS foreign_table_schema,\n        ccu.table_name::text AS foreign_table_name,\n        ccu.column_name::text AS foreign_column_name \n    FROM \n        information_schema.table_constraints AS tc \n        JOIN information_schema.key_column_usage AS kcu\n          ON tc.constraint_name = kcu.constraint_name\n          AND tc.table_schema = kcu.table_schema\n        JOIN information_schema.constraint_column_usage AS ccu\n          ON ccu.constraint_name = tc.constraint_name\n          AND ccu.table_schema = tc.table_schema\n    WHERE tc.constraint_name = p_constraint_name;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_table_foreign_keys",
    "arguments": "p_table_name text",
    "return_type": "TABLE(table_schema text, constraint_name text, table_name text, column_name text, foreign_table_schema text, foreign_table_name text, foreign_column_name text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT\n        tc.table_schema::text, \n        tc.constraint_name::text, \n        tc.table_name::text, \n        kcu.column_name::text, \n        ccu.table_schema::text AS foreign_table_schema,\n        ccu.table_name::text AS foreign_table_name,\n        ccu.column_name::text AS foreign_column_name \n    FROM \n        information_schema.table_constraints AS tc \n        JOIN information_schema.key_column_usage AS kcu\n          ON tc.constraint_name = kcu.constraint_name\n          AND tc.table_schema = kcu.table_schema\n        JOIN information_schema.constraint_column_usage AS ccu\n          ON ccu.constraint_name = tc.constraint_name\n          AND ccu.table_schema = tc.table_schema\n    WHERE tc.table_name = p_table_name\n    AND tc.constraint_type = 'FOREIGN KEY';\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_table_columns",
    "arguments": "p_table_name text",
    "return_type": "TABLE(column_name text, data_type text, is_nullable text, column_default text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name,\n        c.data_type,\n        c.is_nullable,\n        c.column_default\n    FROM information_schema.columns c\n    WHERE c.table_schema = 'public'\n    AND c.table_name = p_table_name;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_all_table_definitions",
    "arguments": "",
    "return_type": "TABLE(create_statement text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT 'CREATE TABLE ' || tablename || ' (' || string_agg(column_definition, ', ' ORDER BY ordinal_position) || ');'\n    FROM (\n        SELECT\n            t.tablename,\n            c.ordinal_position,\n            c.column_name || ' ' || c.data_type || \n            CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END || \n            CASE WHEN c.is_nullable = 'NO' THEN ' NOT NULL' ELSE '' END || \n            CASE WHEN c.column_default IS NOT NULL THEN ' DEFAULT ' || c.column_default ELSE '' END as column_definition\n        FROM pg_catalog.pg_tables t\n        JOIN information_schema.columns c ON t.tablename = c.table_name\n        WHERE t.schemaname = 'public'\n    ) subquery\n    GROUP BY tablename;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_table_constraints",
    "arguments": "p_table_name text",
    "return_type": "json",
    "body": "\nDECLARE\n    result json;\nBEGIN\n    WITH constraints AS (\n        -- Get NOT NULL constraints\n        SELECT \n            'not_null' as constraint_type,\n            column_name,\n            NULL as constraint_definition\n        FROM information_schema.columns \n        WHERE table_name = p_table_name \n        AND is_nullable = 'NO'\n        \n        UNION ALL\n        \n        -- Get CHECK constraints\n        SELECT \n            'check' as constraint_type,\n            pga.attname as column_name,\n            pg_get_constraintdef(pgc.oid) as constraint_definition\n        FROM pg_constraint pgc\n        JOIN pg_namespace nsp ON nsp.oid = pgc.connamespace\n        JOIN pg_class cls ON pgc.conrelid = cls.oid\n        LEFT JOIN pg_attribute pga ON pga.attrelid = pgc.conrelid \n            AND pga.attnum = ANY(pgc.conkey)\n        WHERE cls.relname = p_table_name\n        AND pgc.contype = 'c'\n    )\n    SELECT json_build_object(\n        'not_null', (\n            SELECT json_agg(column_name)\n            FROM constraints \n            WHERE constraint_type = 'not_null'\n        ),\n        'check', (\n            SELECT json_agg(\n                json_build_object(\n                    'column', column_name,\n                    'constraint', constraint_definition\n                )\n            )\n            FROM constraints \n            WHERE constraint_type = 'check'\n        )\n    ) INTO result;\n    \n    RETURN result;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_table_columns_with_unique",
    "arguments": "p_table_name text",
    "return_type": "TABLE(column_name text, data_type text, is_nullable text, column_default text, is_unique text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name::text, \n        c.data_type::text, \n        c.is_nullable::text, \n        c.column_default::text,\n        CASE \n            WHEN kcu.column_name IS NOT NULL THEN 'YES' \n            ELSE 'NO' \n        END AS is_unique\n    FROM \n        information_schema.columns c\n    LEFT JOIN \n        information_schema.key_column_usage kcu \n        ON c.table_name = kcu.table_name \n        AND c.column_name = kcu.column_name \n        AND c.table_schema = kcu.table_schema\n    LEFT JOIN \n        information_schema.table_constraints tc \n        ON kcu.constraint_name = tc.constraint_name \n        AND kcu.table_schema = tc.table_schema\n    WHERE \n        c.table_schema = 'public' \n        AND c.table_name = p_table_name;\n        -- AND tc.constraint_type = 'UNIQUE';\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "extensions",
    "name": "grant_pg_net_access",
    "arguments": "",
    "return_type": "event_trigger",
    "body": "\n  BEGIN\n    IF EXISTS (\n      SELECT 1\n      FROM pg_event_trigger_ddl_commands() AS ev\n      JOIN pg_extension AS ext\n      ON ev.objid = ext.oid\n      WHERE ext.extname = 'pg_net'\n    )\n    THEN\n      IF NOT EXISTS (\n        SELECT 1\n        FROM pg_roles\n        WHERE rolname = 'supabase_functions_admin'\n      )\n      THEN\n        CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n      END IF;\n\n      GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n      IF EXISTS (\n        SELECT FROM pg_extension\n        WHERE extname = 'pg_net'\n        -- all versions in use on existing projects as of 2025-02-20\n        -- version 0.12.0 onwards don't need these applied\n        AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8.0', '0.10.0', '0.11.0')\n      ) THEN\n        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n        REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n        REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n        GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n        GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      END IF;\n    END IF;\n  END;\n  ",
    "description": "Grants access to pg_net",
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_foreign_keys",
    "arguments": "schema_name text",
    "return_type": "json",
    "body": "\nbegin\n  return (\n    select json_object_agg(\n      tc.table_name,\n      json_agg(\n        json_build_object(\n          'column_name', kcu.column_name,\n          'foreign_table', ccu.table_name,\n          'foreign_column', ccu.column_name\n        )\n      )\n    )\n    from information_schema.table_constraints tc\n    join information_schema.key_column_usage kcu \n      on tc.constraint_name = kcu.constraint_name\n    join information_schema.constraint_column_usage ccu \n      on tc.constraint_name = ccu.constraint_name\n    where tc.constraint_type = 'FOREIGN KEY'\n      and tc.table_schema = schema_name\n    group by tc.table_name\n  );\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_functions",
    "arguments": "schema_name text",
    "return_type": "json",
    "body": "\nbegin\n  return (\n    select json_agg(\n      json_build_object(\n        'function_name', p.proname,\n        'definition', pg_get_functiondef(p.oid)\n      )\n    )\n    from pg_proc p\n    join pg_namespace n on p.pronamespace = n.oid\n    where n.nspname = schema_name\n  );\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_triggers",
    "arguments": "schema_name text",
    "return_type": "json",
    "body": "\nbegin\n  return (\n    select json_agg(\n      json_build_object(\n        'trigger_name', trigger_name,\n        'event_manipulation', event_manipulation,\n        'event_object_table', event_object_table,\n        'action_statement', action_statement\n      )\n    )\n    from information_schema.triggers\n    where trigger_schema = schema_name\n  );\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_table_definition",
    "arguments": "p_table_name text",
    "return_type": "SETOF text",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT\n        'CREATE TABLE ' || tablename || ' (' ||\n        string_agg(column_definition, ', ' ORDER BY ordinal_position) ||\n        ');'\n    FROM (\n        SELECT\n            t.tablename,\n            c.ordinal_position,\n            c.column_name || ' ' || c.data_type ||\n            CASE WHEN c.character_maximum_length IS NOT NULL\n                 THEN '(' || c.character_maximum_length || ')'\n                 ELSE ''\n            END ||\n            CASE WHEN c.is_nullable = 'NO' THEN ' NOT NULL' ELSE '' END ||\n            CASE WHEN c.column_default IS NOT NULL\n                 THEN ' DEFAULT ' || c.column_default\n                 ELSE ''\n            END as column_definition\n        FROM pg_catalog.pg_tables t\n        JOIN information_schema.columns c\n             ON t.tablename = c.table_name\n        WHERE t.schemaname = 'public'\n        AND t.tablename = p_table_name\n    ) subquery\n    GROUP BY tablename;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_schema_info",
    "arguments": "schema_name text",
    "return_type": "json",
    "body": "\nbegin\n  return (\n    select json_object_agg(\n      t.table_name,\n      json_build_object(\n        'columns', (\n          select json_agg(\n            json_build_object(\n              'column_name', c.column_name,\n              'data_type', c.data_type,\n              'is_nullable', c.is_nullable,\n              'column_default', c.column_default\n            )\n          )\n          from information_schema.columns c\n          where c.table_name = t.table_name\n            and c.table_schema = schema_name\n        )\n      )\n    )\n    from information_schema.tables t\n    where t.table_schema = schema_name\n      and t.table_type = 'BASE TABLE'\n  );\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_all_foreign_keys",
    "arguments": "",
    "return_type": "json",
    "body": "\nbegin\n  return (\n    select json_object_agg(\n      source_table,\n      foreign_keys\n    )\n    from (\n      select \n        tc.table_name as source_table,\n        json_agg(\n          json_build_object(\n            'constraint_name', tc.constraint_name,\n            'column_name', kcu.column_name,\n            'foreign_table', ccu.table_name,\n            'foreign_column', ccu.column_name,\n            'on_update', rc.update_rule,\n            'on_delete', rc.delete_rule\n          ) order by kcu.column_name\n        ) as foreign_keys\n      from information_schema.table_constraints tc\n      join information_schema.key_column_usage kcu\n        on tc.constraint_name = kcu.constraint_name\n        and tc.table_schema = kcu.table_schema\n      join information_schema.constraint_column_usage ccu\n        on ccu.constraint_name = tc.constraint_name\n        and ccu.table_schema = tc.table_schema\n      join information_schema.referential_constraints rc\n        on tc.constraint_name = rc.constraint_name\n      where tc.constraint_type = 'FOREIGN KEY'\n        and tc.table_schema = 'public'\n      group by tc.table_name\n    ) fk_info\n  );\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_table_columns_with_constraints_and_triggers",
    "arguments": "p_table_name text",
    "return_type": "TABLE(column_name text, data_type text, is_nullable text, column_default text, is_unique text, foreign_key text, trigger_name text)",
    "body": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name::text, \n        c.data_type::text, \n        c.is_nullable::text, \n        c.column_default::text,\n        CASE \n            WHEN kcu.column_name IS NOT NULL THEN 'YES' \n            ELSE 'NO' \n        END AS is_unique,\n        fk.constraint_name AS foreign_key,\n        t.tgname AS trigger_name\n    FROM \n        information_schema.columns c\n    LEFT JOIN \n        information_schema.key_column_usage kcu \n        ON c.table_name = kcu.table_name \n        AND c.column_name = kcu.column_name \n        AND c.table_schema = kcu.table_schema\n    LEFT JOIN \n        information_schema.table_constraints tc \n        ON kcu.constraint_name = tc.constraint_name \n        AND kcu.table_schema = tc.table_schema\n    LEFT JOIN \n        information_schema.referential_constraints rc \n        ON tc.constraint_name = rc.constraint_name \n        AND tc.table_schema = rc.constraint_schema\n    LEFT JOIN \n        information_schema.table_constraints fk \n        ON rc.unique_constraint_name = fk.constraint_name \n        AND rc.unique_constraint_schema = fk.table_schema\n    LEFT JOIN \n        pg_trigger t \n        ON t.tgrelid = (SELECT oid FROM pg_class WHERE relname = p_table_name AND relnamespace = 'public'::regnamespace)\n    WHERE \n        c.table_schema = 'public' \n        AND c.table_name = p_table_name;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_table_metadata",
    "arguments": "p_target_table text",
    "return_type": "jsonb",
    "body": "\nDECLARE\n  result jsonb;\nBEGIN\n  -- Get basic table information\n  WITH table_info AS (\n    SELECT \n      c.relname AS table_name,\n      obj_description(c.oid) AS table_description,\n      pg_size_pretty(pg_total_relation_size(c.oid)) AS table_size,\n      pg_total_relation_size(c.oid) AS table_size_bytes,\n      (SELECT COUNT(*) FROM pg_stat_user_tables WHERE relname = c.relname) > 0 AS is_user_table,\n      to_char(GREATEST(\n        (SELECT max(last_vacuum) FROM pg_stat_user_tables WHERE relname = c.relname),\n        (SELECT max(last_autovacuum) FROM pg_stat_user_tables WHERE relname = c.relname)\n      ), 'YYYY-MM-DD HH24:MI:SS') AS last_vacuum,\n      to_char(GREATEST(\n        (SELECT max(last_analyze) FROM pg_stat_user_tables WHERE relname = c.relname),\n        (SELECT max(last_autoanalyze) FROM pg_stat_user_tables WHERE relname = c.relname)\n      ), 'YYYY-MM-DD HH24:MI:SS') AS last_analyze,\n      (SELECT count(*) FROM pg_stat_user_tables WHERE relname = c.relname) AS row_count\n    FROM pg_class c\n    WHERE c.relname = p_target_table AND c.relkind = 'r'\n  ),\n  \n  -- Get columns information\n  columns AS (\n    SELECT \n      a.attname AS column_name,\n      pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,\n      CASE \n        WHEN a.attnotnull THEN true\n        ELSE false\n      END AS is_not_null,\n      CASE \n        WHEN (SELECT COUNT(*) FROM pg_constraint\n              WHERE conrelid = a.attrelid\n              AND conkey[1] = a.attnum\n              AND contype = 'p') > 0 THEN true\n        ELSE false\n      END AS is_primary_key,\n      CASE \n        WHEN a.atthasdef THEN pg_get_expr(d.adbin, d.adrelid)\n        ELSE NULL\n      END AS default_value,\n      col_description(a.attrelid, a.attnum) AS column_description,\n      a.attnum AS ordinal_position\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef d ON a.attrelid = d.adrelid AND a.attnum = d.adnum\n    WHERE a.attrelid = p_target_table::regclass\n    AND a.attnum > 0\n    AND NOT a.attisdropped\n    ORDER BY a.attnum\n  ),\n  \n  -- Get constraint information\n  constraints AS (\n    SELECT\n      con.conname AS constraint_name,\n      con.contype AS constraint_type,\n      CASE\n        WHEN con.contype = 'p' THEN 'PRIMARY KEY'\n        WHEN con.contype = 'u' THEN 'UNIQUE'\n        WHEN con.contype = 'f' THEN 'FOREIGN KEY'\n        WHEN con.contype = 'c' THEN 'CHECK'\n        ELSE con.contype::text\n      END AS constraint_type_desc,\n      pg_get_constraintdef(con.oid) AS constraint_definition,\n      con.conkey AS constraint_columns,\n      con.confrelid::regclass::text AS referenced_table,\n      con.confkey AS referenced_columns\n    FROM pg_constraint con\n    JOIN pg_class rel ON rel.oid = con.conrelid\n    WHERE rel.relname = p_target_table\n  ),\n  \n  -- Get index information\n  indexes AS (\n    SELECT\n      i.relname AS index_name,\n      am.amname AS index_type,\n      pg_get_indexdef(i.oid) AS index_definition,\n      idx.indisunique AS is_unique,\n      idx.indisprimary AS is_primary,\n      idx.indisexclusion AS is_exclusion,\n      idx.indimmediate AS is_immediate,\n      idx.indisclustered AS is_clustered,\n      idx.indisvalid AS is_valid,\n      array_to_string(array_agg(a.attname), ', ') AS index_columns\n    FROM pg_index idx\n    JOIN pg_class i ON i.oid = idx.indexrelid\n    JOIN pg_class t ON t.oid = idx.indrelid\n    JOIN pg_am am ON am.oid = i.relam\n    JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(idx.indkey)\n    WHERE t.relname = p_target_table\n    GROUP BY i.relname, am.amname, idx.indisunique, idx.indisprimary, \n             idx.indisexclusion, idx.indimmediate, idx.indisclustered, \n             idx.indisvalid, i.oid\n  ),\n  \n  -- Get trigger information\n  triggers AS (\n    SELECT\n      trg.tgname AS trigger_name,\n      pg_get_triggerdef(trg.oid) AS trigger_definition,\n      CASE \n        WHEN trg.tgenabled = 'O' THEN 'ENABLED'\n        WHEN trg.tgenabled = 'D' THEN 'DISABLED'\n        WHEN trg.tgenabled = 'R' THEN 'REPLICA'\n        WHEN trg.tgenabled = 'A' THEN 'ALWAYS'\n        ELSE trg.tgenabled::text\n      END AS trigger_status\n    FROM pg_trigger trg\n    JOIN pg_class tbl ON tbl.oid = trg.tgrelid\n    WHERE NOT trg.tgisinternal\n    AND tbl.relname = p_target_table\n  ),\n  \n  -- Get foreign key information\n  foreign_keys AS (\n    SELECT\n      con.conname AS fk_name,\n      src_table.relname AS source_table,\n      src_att.attname AS source_column,\n      tgt_table.relname AS target_table,\n      tgt_att.attname AS target_column,\n      CASE con.confupdtype\n        WHEN 'a' THEN 'NO ACTION'\n        WHEN 'r' THEN 'RESTRICT'\n        WHEN 'c' THEN 'CASCADE'\n        WHEN 'n' THEN 'SET NULL'\n        WHEN 'd' THEN 'SET DEFAULT'\n        ELSE 'UNKNOWN'\n      END AS on_update,\n      CASE con.confdeltype\n        WHEN 'a' THEN 'NO ACTION'\n        WHEN 'r' THEN 'RESTRICT'\n        WHEN 'c' THEN 'CASCADE'\n        WHEN 'n' THEN 'SET NULL'\n        WHEN 'd' THEN 'SET DEFAULT'\n        ELSE 'UNKNOWN'\n      END AS on_delete\n    FROM pg_constraint con\n    JOIN pg_class src_table ON src_table.oid = con.conrelid\n    JOIN pg_class tgt_table ON tgt_table.oid = con.confrelid\n    JOIN pg_attribute src_att ON src_att.attrelid = con.conrelid AND src_att.attnum = con.conkey[1]\n    JOIN pg_attribute tgt_att ON tgt_att.attrelid = con.confrelid AND tgt_att.attnum = con.confkey[1]\n    WHERE con.contype = 'f'\n    AND (src_table.relname = p_target_table OR tgt_table.relname = p_target_table)\n  ),\n  \n  -- Get RLS policies\n  rls_policies AS (\n    SELECT\n      pol.polname AS policy_name,\n      pol.polcmd AS command,\n      CASE pol.polcmd\n        WHEN 'r' THEN 'SELECT'\n        WHEN 'a' THEN 'INSERT'\n        WHEN 'w' THEN 'UPDATE'\n        WHEN 'd' THEN 'DELETE'\n        WHEN '*' THEN 'ALL'\n        ELSE 'UNKNOWN'\n      END AS command_desc,\n      pol.polpermissive AS is_permissive,\n      pg_get_expr(pol.polqual, pol.polrelid) AS using_expression,\n      pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check_expression,\n      array_to_string(ARRAY(\n        SELECT rolname FROM pg_roles WHERE oid = ANY(pol.polroles)\n      ), ', ') AS roles\n    FROM pg_policy pol\n    JOIN pg_class tbl ON tbl.oid = pol.polrelid\n    WHERE tbl.relname = p_target_table\n  )\n  \n  -- Combine all information into a JSON object\n  SELECT jsonb_build_object(\n    'table_info', (\n      SELECT row_to_json(ti) FROM table_info ti\n    ),\n    'columns', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', column_name,\n          'type', data_type,\n          'not_null', is_not_null,\n          'is_primary_key', is_primary_key,\n          'default', default_value,\n          'description', column_description,\n          'position', ordinal_position\n        )\n      )\n      FROM columns\n    ),\n    'constraints', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', constraint_name,\n          'type', constraint_type,\n          'type_desc', constraint_type_desc,\n          'definition', constraint_definition,\n          'columns', constraint_columns,\n          'referenced_table', referenced_table,\n          'referenced_columns', referenced_columns\n        )\n      )\n      FROM constraints\n    ),\n    'indexes', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', index_name,\n          'type', index_type,\n          'definition', index_definition,\n          'is_unique', is_unique,\n          'is_primary', is_primary,\n          'columns', index_columns\n        )\n      )\n      FROM indexes\n    ),\n    'triggers', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', trigger_name,\n          'definition', trigger_definition,\n          'status', trigger_status\n        )\n      )\n      FROM triggers\n    ),\n    'foreign_keys', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', fk_name,\n          'source_table', source_table,\n          'source_column', source_column,\n          'target_table', target_table,\n          'target_column', target_column,\n          'on_update', on_update,\n          'on_delete', on_delete\n        )\n      )\n      FROM foreign_keys\n    ),\n    'rls_policies', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', policy_name,\n          'command', command,\n          'command_desc', command_desc,\n          'is_permissive', is_permissive,\n          'using_expression', using_expression,\n          'with_check_expression', with_check_expression,\n          'roles', roles\n        )\n      )\n      FROM rls_policies\n    ),\n    'metadata_generated_at', now()\n  ) INTO result;\n\n  RETURN result;\nEND;\n",
    "description": "Returns detailed metadata about the specified database table, including columns, constraints, indexes, triggers, and RLS policies.",
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_user_uuid_by_email",
    "arguments": "email_input text",
    "return_type": "uuid",
    "body": "\nDECLARE\n    user_uuid uuid;\nBEGIN\n    SELECT id INTO user_uuid\n    FROM auth.users\n    WHERE email = email_input;\n\n    RETURN user_uuid;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "get_domain_id_by_name",
    "arguments": "domain_name_input text",
    "return_type": "uuid",
    "body": "\nDECLARE\n    domain_id uuid;\nBEGIN\n    SELECT id INTO domain_id\n    FROM domains\n    WHERE name = domain_name_input;\n\n    RETURN domain_id;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "populate_sources_with_fixed_user_id",
    "arguments": "user_email_address text",
    "return_type": "void",
    "body": "\nDECLARE\n    user_id uuid;\nBEGIN\n    -- Get the domain_id using the provided domain name\n    user_id := get_user_uuid_by_email(user_email_address);\n\n    -- Insert a new record into the sources table\n    INSERT INTO public.sources (\n        user_id\n    ) VALUES (\n        user_id\n    );\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "add_unique_constraint",
    "arguments": "p_table_name text, p_column_name text",
    "return_type": "void",
    "body": "\nDECLARE\n    constraint_name text;\n    constraint_exists boolean;\nBEGIN\n    -- Generate a unique constraint name based on the table and column names\n    constraint_name := format('uq_%I_%I', p_table_name, p_column_name);\n\n    -- Check if the unique constraint already exists\n    SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.table_constraints tc\n        JOIN information_schema.key_column_usage kcu \n            ON tc.constraint_name = kcu.constraint_name \n            AND tc.table_schema = kcu.table_schema\n        WHERE \n            tc.table_name = p_table_name \n            AND kcu.column_name = p_column_name \n            AND tc.constraint_type = 'UNIQUE'\n    ) INTO constraint_exists;\n\n    IF constraint_exists THEN\n        RAISE NOTICE 'Unique constraint % already exists on table % for column %', constraint_name, p_table_name, p_column_name;\n        RETURN;  -- Exit the function if the constraint already exists\n    END IF;\n\n    -- Execute the command to add the unique constraint\n    EXECUTE format('ALTER TABLE %I ADD CONSTRAINT %I UNIQUE (%I)', \n                   p_table_name, \n                   constraint_name, \n                   p_column_name);\n    \n    RAISE NOTICE 'Unique constraint % added to table % on column %', constraint_name, p_table_name, p_column_name;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "public",
    "name": "handle_new_user",
    "arguments": "",
    "return_type": "trigger",
    "body": "\nBEGIN\n    -- Add debug logging\n    RAISE NOTICE 'Creating profile for user: %', NEW.id;\n    \n    -- Check if profile already exists\n    IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN\n        RAISE NOTICE 'Profile already exists for user: %', NEW.id;\n        RETURN NEW;\n    END IF;\n\n    -- Attempt to create profile\n    BEGIN\n        INSERT INTO public.profiles (id, email)\n        VALUES (NEW.id, NEW.email);\n        RAISE NOTICE 'Profile created successfully for user: %', NEW.id;\n    EXCEPTION WHEN OTHERS THEN\n        -- Log the error details\n        RAISE NOTICE 'Error creating profile: % %', SQLERRM, SQLSTATE;\n        RETURN NULL; -- This will abort the transaction\n    END;\n\n    RETURN NEW;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "set_current_domain",
    "arguments": "domain_id uuid",
    "return_type": "void",
    "body": "\nbegin\n  -- Set the domain_id in the session\n  perform set_config('app.current_domain_id', domain_id::text, false);\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": true
  },
  {
    "schema": "public",
    "name": "get_dynamic_healing_domain_id",
    "arguments": "",
    "return_type": "uuid",
    "body": "\nBEGIN\n    RETURN (SELECT id FROM domains WHERE name = 'Dynamic Healing Group' LIMIT 1);\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "postgres",
    "security_definer": false
  },
  {
    "schema": "auth",
    "name": "jwt",
    "arguments": "",
    "return_type": "jsonb",
    "body": "\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n",
    "description": null,
    "volatility": "s",
    "owner": "supabase_auth_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "foldername",
    "arguments": "name text",
    "return_type": "text[]",
    "body": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "filename",
    "arguments": "name text",
    "return_type": "text",
    "body": "\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "extension",
    "arguments": "name text",
    "return_type": "text",
    "body": "\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "get_size_by_bucket",
    "arguments": "",
    "return_type": "TABLE(size bigint, bucket_id text)",
    "body": "\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "body": "\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "can_insert_object",
    "arguments": "bucketid text, name text, owner uuid, metadata jsonb",
    "return_type": "void",
    "body": "\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "list_objects_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text",
    "return_type": "TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)",
    "body": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "list_multipart_uploads_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text",
    "return_type": "TABLE(key text, id text, created_at timestamp with time zone)",
    "body": "\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "search",
    "arguments": "prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text",
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "body": "\ndeclare\n  v_order_by text;\n  v_sort_order text;\nbegin\n  case\n    when sortcolumn = 'name' then\n      v_order_by = 'name';\n    when sortcolumn = 'updated_at' then\n      v_order_by = 'updated_at';\n    when sortcolumn = 'created_at' then\n      v_order_by = 'created_at';\n    when sortcolumn = 'last_accessed_at' then\n      v_order_by = 'last_accessed_at';\n    else\n      v_order_by = 'name';\n  end case;\n\n  case\n    when sortorder = 'asc' then\n      v_sort_order = 'asc';\n    when sortorder = 'desc' then\n      v_sort_order = 'desc';\n    else\n      v_sort_order = 'asc';\n  end case;\n\n  v_order_by = v_order_by || ' ' || v_sort_order;\n\n  return query execute\n    'with folders as (\n       select path_tokens[$1] as folder\n       from storage.objects\n         where objects.name ilike $2 || $3 || ''%''\n           and bucket_id = $4\n           and array_length(objects.path_tokens, 1) <> $1\n       group by folder\n       order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n",
    "description": null,
    "volatility": "s",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "storage",
    "name": "operation",
    "arguments": "",
    "return_type": "text",
    "body": "\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n",
    "description": null,
    "volatility": "s",
    "owner": "supabase_storage_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "cast",
    "arguments": "val text, type_ regtype",
    "return_type": "jsonb",
    "body": "\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    ",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "to_regrole",
    "arguments": "role_name text",
    "return_type": "regrole",
    "body": " select role_name::regrole ",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "topic",
    "arguments": "",
    "return_type": "text",
    "body": "\nselect nullif(current_setting('realtime.topic', true), '')::text;\n",
    "description": null,
    "volatility": "s",
    "owner": "supabase_realtime_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "is_visible_through_filters",
    "arguments": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "return_type": "boolean",
    "body": "\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    ",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "apply_rls",
    "arguments": "wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)",
    "return_type": "SETOF realtime.wal_rls",
    "body": "\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "quote_wal2json",
    "arguments": "entity regclass",
    "return_type": "text",
    "body": "\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    ",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "list_changes",
    "arguments": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "return_type": "SETOF realtime.wal_rls",
    "body": "\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "send",
    "arguments": "payload jsonb, event text, topic text, private boolean DEFAULT true",
    "return_type": "void",
    "body": "\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'realtime.send',\n              'event', event,\n              'topic', topic,\n              'private', private\n          )::text\n      );\n  END;\nEND;\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "broadcast_changes",
    "arguments": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text",
    "return_type": "void",
    "body": "\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "build_prepared_statement_sql",
    "arguments": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "return_type": "text",
    "body": "\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "check_equality_op",
    "arguments": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "return_type": "boolean",
    "body": "\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      ",
    "description": null,
    "volatility": "i",
    "owner": "supabase_admin",
    "security_definer": false
  },
  {
    "schema": "realtime",
    "name": "subscription_check_filters",
    "arguments": "",
    "return_type": "trigger",
    "body": "\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    ",
    "description": null,
    "volatility": "v",
    "owner": "supabase_admin",
    "security_definer": false
  }
]