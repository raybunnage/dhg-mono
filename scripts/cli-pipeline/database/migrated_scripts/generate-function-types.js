#!/usr/bin/env node

/**
 * Generate TypeScript interfaces from exported PostgreSQL functions
 * 
 * This script reads the exported functions.json file and generates TypeScript
 * interfaces for function parameters and return types.
 * 
 * Usage:
 *   node generate-function-types.js [input-file] [output-file]
 * 
 * Example:
 *   node generate-function-types.js ../supabase/functions.json ../apps/dhg-improve-experts/src/types/dbFunctions.ts
 */

const fs = require('fs');
const path = require('path');

// Get input and output file paths from command line arguments
const inputFile = process.argv[2] || path.join(__dirname, '../supabase/functions.json');
const outputFile = process.argv[3] || path.join(__dirname, '../apps/dhg-improve-experts/src/types/dbFunctions.ts');

// Check if input file exists
if (!fs.existsSync(inputFile)) {
  console.error(`Error: Input file '${inputFile}' not found.`);
  console.error('Run pnpm db:export-functions first to generate the functions.json file.');
  process.exit(1);
}

// Read and parse the functions JSON file
let functions;
try {
  const data = fs.readFileSync(inputFile, 'utf8');
  functions = JSON.parse(data);
  
  if (!Array.isArray(functions)) {
    console.error('Error: Functions data is not an array.');
    process.exit(1);
  }
} catch (error) {
  console.error(`Error reading or parsing functions file: ${error.message}`);
  process.exit(1);
}

// Create output directory if it doesn't exist
const outputDir = path.dirname(outputFile);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Map PostgreSQL types to TypeScript types
function mapPgTypeToTs(pgType) {
  const typeMap = {
    'integer': 'number',
    'bigint': 'number',
    'smallint': 'number',
    'decimal': 'number',
    'numeric': 'number',
    'real': 'number',
    'double precision': 'number',
    'text': 'string',
    'character varying': 'string',
    'varchar': 'string',
    'char': 'string',
    'boolean': 'boolean',
    'json': 'Record<string, any>',
    'jsonb': 'Record<string, any>',
    'timestamp': 'string', // or Date
    'timestamp with time zone': 'string', // or Date
    'date': 'string', // or Date
    'time': 'string',
    'uuid': 'string',
    'bytea': 'Uint8Array',
    'void': 'void',
  };

  // Handle array types
  if (pgType.endsWith('[]')) {
    const baseType = pgType.slice(0, -2);
    return `${mapPgTypeToTs(baseType)}[]`;
  }

  // Handle custom types or types not in the map
  return typeMap[pgType] || 'any';
}

// Parse function arguments
function parseArguments(argsString) {
  if (!argsString || argsString === '') return [];
  
  // Split by commas, but respect parentheses (for complex types)
  const args = [];
  let currentArg = '';
  let parenCount = 0;
  
  for (let i = 0; i < argsString.length; i++) {
    const char = argsString[i];
    
    if (char === '(') parenCount++;
    else if (char === ')') parenCount--;
    
    if (char === ',' && parenCount === 0) {
      args.push(currentArg.trim());
      currentArg = '';
    } else {
      currentArg += char;
    }
  }
  
  if (currentArg.trim()) {
    args.push(currentArg.trim());
  }
  
  return args.map(arg => {
    const parts = arg.split(' ');
    // The last part is the type
    const type = parts.slice(1).join(' ');
    // The first part is the name
    const name = parts[0].replace(/^IN\s+/i, '');
    
    return { name, type };
  });
}

// Generate TypeScript interfaces
function generateTypeScriptInterfaces(functions) {
  let output = `/**
 * Auto-generated TypeScript interfaces for PostgreSQL functions
 * Generated on ${new Date().toISOString()}
 * 
 * DO NOT EDIT DIRECTLY - This file is generated by generate-function-types.js
 */

/**
 * Database function parameter and return types
 */

`;

  // Generate interfaces for each function
  functions.forEach(func => {
    const functionName = func.name;
    const schemaName = func.schema;
    const fullName = `${schemaName}_${functionName}`;
    const args = parseArguments(func.arguments);
    
    // Generate params interface
    if (args.length > 0) {
      output += `/**
 * Parameters for ${schemaName}.${functionName}
 */
export interface ${fullName}Params {
${args.map(arg => `  ${arg.name}: ${mapPgTypeToTs(arg.type)};`).join('\n')}
}

`;
    }
    
    // Generate return type
    output += `/**
 * Return type for ${schemaName}.${functionName}
 */
export type ${fullName}Result = ${mapPgTypeToTs(func.return_type)};

`;
  });

  // Generate function map type
  output += `/**
 * Map of all database functions
 */
export interface DbFunctions {
${functions.map(func => {
  const fullName = `${func.schema}_${func.name}`;
  const args = parseArguments(func.arguments);
  
  if (args.length > 0) {
    return `  ${func.schema}_${func.name}: (params: ${fullName}Params) => Promise<${fullName}Result>;`;
  } else {
    return `  ${func.schema}_${func.name}: () => Promise<${fullName}Result>;`;
  }
}).join('\n')}
}
`;

  return output;
}

// Generate the TypeScript interfaces
const typeScriptCode = generateTypeScriptInterfaces(functions);

// Write the output file
try {
  fs.writeFileSync(outputFile, typeScriptCode);
  console.log(`Successfully generated TypeScript interfaces at ${outputFile}`);
  console.log(`Generated interfaces for ${functions.length} functions`);
} catch (error) {
  console.error(`Error writing output file: ${error.message}`);
  process.exit(1);
} 