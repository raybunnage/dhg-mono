#!/bin/bash

# Generate test scripts for all Alpha pipelines
# Based on the successful Gamma testing approach

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"

# List of Alpha pipelines that need tests
ALPHA_PIPELINES=(
    "testing"
    "utilities"
    "system"
    "registry"
    "tracking"
    "maintenance"
    "continuous"
    "proxy"
    "servers"
    "monitoring"
    "shared-services"
    "service_dependencies"
    "refactor_tracking"
    "deprecation"
    "all_pipelines"
    "database"
    "deployment"
)

# Function to get commands for each pipeline
get_pipeline_commands() {
    case "$1" in
        "testing") echo "test-existence test-priority test-pipeline test-all coverage report health-check" ;;
        "utilities") echo "check-env fix-vite-env diagnose-vite kill-vite clear-cache fix-app-env find-process list-apps health-check" ;;
        "system") echo "status check-env verify-setup health-check list-services check-dependencies" ;;
        "registry") echo "list search add update remove validate sync import export health-check" ;;
        "tracking") echo "track list stats report clean disable enable status health-check" ;;
        "maintenance") echo "clean-temp clean-logs clean-cache health-check analyze-disk check-permissions fix-permissions backup-config" ;;
        "continuous") echo "start stop status list schedule unschedule run-now health-check" ;;
        "proxy") echo "start stop status list start-all stop-all restart health-check" ;;
        "servers") echo "start stop status list-running list-available restart restart-all health-check" ;;
        "monitoring") echo "start stop status check-health check-metrics report dashboard health-check" ;;
        "shared-services") echo "list status check validate analyze health-check update-registry scan-usage" ;;
        "service_dependencies") echo "analyze visualize check update scan report health-check" ;;
        "refactor_tracking") echo "track list status report progress update complete health-check" ;;
        "deprecation") echo "scan analyze report mark-deprecated check-usage generate-migration health-check" ;;
        "all_pipelines") echo "list status health-checks run-all report sync update scan" ;;
        "database") echo "table-records empty-tables database-functions list-views table-structure connection-test db-health-check schema-health" ;;
        "deployment") echo "validate-all validate-typescript validate-dependencies validate-env status health-check history" ;;
    esac
}

# Get the CLI script name for a pipeline
get_cli_script_name() {
    case "$1" in
        "service_dependencies") echo "service-dependencies-cli.sh" ;;
        "refactor_tracking") echo "refactor-tracking-cli.sh" ;;
        "all_pipelines") echo "all-pipelines-cli.sh" ;;
        *) echo "$1-cli.sh" ;;
    esac
}

# Generate test for a single pipeline
generate_pipeline_test() {
    local pipeline="$1"
    local cli_script_name=$(get_cli_script_name "$pipeline")
    
    # Special handling for maintenance at root level
    if [[ "$pipeline" == "maintenance" ]]; then
        local test_dir="$PROJECT_ROOT/scripts/cli-pipeline/tests"
        local test_file="$test_dir/test-maintenance-cli.sh"
    else
        local test_dir="$PROJECT_ROOT/scripts/cli-pipeline/$pipeline/tests"
        local test_file="$test_dir/test-${cli_script_name%.sh}.sh"
    fi
    
    # Skip if test already exists
    if [[ -f "$test_file" ]]; then
        echo "Test already exists for $pipeline, skipping..."
        return 0
    fi
    
    echo "Generating test for $pipeline pipeline..."
    
    # Create test directory
    mkdir -p "$test_dir"
    
    # Get commands for this pipeline
    local commands=$(get_pipeline_commands "$pipeline")
    
    # Generate test file
    cat > "$test_file" << EOF
#!/bin/bash

# Test suite for $pipeline CLI pipeline
# Generated by Alpha test generator

set -e

# Get script directory
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="\$(cd "\$SCRIPT_DIR/../../../.." && pwd)"

# Source test framework
source "\$PROJECT_ROOT/scripts/cli-pipeline/testing/test-framework.sh"

# The CLI script to test
EOF
    
    # Add the correct CLI script path based on pipeline
    if [[ "$pipeline" == "maintenance" ]]; then
        cat >> "$test_file" << 'EOF'
CLI_SCRIPT="$SCRIPT_DIR/../../maintenance-cli.sh"
EOF
    else
        cat >> "$test_file" << EOF
CLI_SCRIPT="\$SCRIPT_DIR/../$cli_script_name"
EOF
    fi

    cat >> "$test_file" << 'EOF'

# Initialize test environment
init_test_environment "$pipeline CLI Pipeline"

# Test 1: Script exists and is executable
start_test "Script existence and permissions"
assert_file_exists "\$CLI_SCRIPT"
assert_file_executable "\$CLI_SCRIPT"

# Test 2: Help command works
start_test "Help command"
assert_command_success "\$CLI_SCRIPT" "help"
assert_command_output_contains "\$CLI_SCRIPT help" "$pipeline"

# Test 3: Unknown command handling
start_test "Unknown command handling"
assert_command_fails "\$CLI_SCRIPT" "unknown-command-xyz"
assert_command_output_contains "\$CLI_SCRIPT unknown-command-xyz 2>&1 || true" "Unknown command"

# Test 4: Basic command availability
start_test "Basic commands availability"
EOF

    # Add command-specific tests
    for cmd in $commands; do
        cat >> "$test_file" << EOF
assert_command_exists "\$CLI_SCRIPT" "$cmd"
EOF
    done

    # Add health check pattern test if pipeline has health-check
    if [[ "$commands" == *"health-check"* ]]; then
        cat >> "$test_file" << EOF

# Test 5: Health check functionality
start_test "Health check functionality"
assert_command_runs "\$CLI_SCRIPT" "health-check"
# Health check might warn about missing services but shouldn't fail
assert_no_command_errors "\$CLI_SCRIPT health-check 2>&1 || true"
EOF
    fi

    # Add command routing tests
    cat >> "$test_file" << EOF

# Test 6: Command routing
start_test "Command routing"
EOF

    # Test first few commands more thoroughly
    local first_commands=($(echo $commands | tr ' ' '\n' | head -3))
    for cmd in "${first_commands[@]}"; do
        cat >> "$test_file" << EOF
test_output=\$("\$CLI_SCRIPT" "$cmd" 2>&1 || true)
if echo "\$test_output" | grep -q "Unknown command"; then
    fail "Command '$cmd' not properly routed"
else
    pass "Command '$cmd' is routed correctly"
fi
EOF
    done

    # Add fallback handling test
    cat >> "$test_file" << EOF

# Test 7: Base class integration
start_test "Base class integration"
# Should show framework info in help
assert_command_output_contains "\$CLI_SCRIPT --help 2>&1 || true" "Base Class\\|Pipeline\\|SimpleCLIPipeline"

# Test 8: Error handling
start_test "Error handling"
# Should handle missing arguments gracefully
assert_command_runs "\$CLI_SCRIPT" ""
# Empty command should show help
assert_command_output_contains "\$CLI_SCRIPT 2>&1 || true" "help\\|usage\\|Usage\\|USAGE"

# Test 9: Pipeline metadata
start_test "Pipeline metadata"
test_output=\$("\$CLI_SCRIPT" help 2>&1)
assert_not_empty "\$test_output" "Help output should not be empty"

# Verify pipeline name appears in help
if echo "\$test_output" | grep -qi "$pipeline"; then
    pass "Pipeline name appears in help"
else
    fail "Pipeline name missing from help"
fi

# Cleanup and summarize
cleanup_test_environment

# Exit with appropriate code
if [ \$FAIL_COUNT -gt 0 ]; then
    exit 1
fi

exit 0
EOF

    # Make test executable
    chmod +x "$test_file"
    
    echo "Generated test: $test_file"
}

# Generate all tests
echo "=== Generating Alpha Pipeline Tests ==="
echo "Based on the SimpleCLIPipeline pattern"
echo

for pipeline in "${ALPHA_PIPELINES[@]}"; do
    generate_pipeline_test "$pipeline"
done

echo
echo "=== Test Generation Complete ==="
echo "Generated tests for ${#ALPHA_PIPELINES[@]} Alpha pipelines"
echo
echo "To run all Alpha tests:"
echo "  ./scripts/cli-pipeline/testing/run-alpha-tests.sh"
echo
echo "To run a specific test:"
echo "  ./scripts/cli-pipeline/<pipeline>/tests/test-<pipeline>-cli.sh"