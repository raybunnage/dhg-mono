# Script Manager Technical Specification

## Overview

This document outlines the technical specifications for implementing script management functionality similar to the existing document management system. The implementation will create two new scripts: `script-manager.sh` and `script-pipeline-main.sh`, which will handle the finding, syncing, adding, and classifying of script files (`.sh` and `.js`) in the system.

## Table Schema

The scripts table already exists in Supabase with the following schema:

| Column Name | Data Type | Default | Nullable | Description |
|-------------|-----------|---------|----------|-------------|
| id | uuid | gen_random_uuid() | NO | Primary key |
| file_path | text | | NO | Path to script file |
| title | text | | NO | Script title |
| summary | jsonb | | YES | Script summary information |
| language | text | | NO | Script language (sh, js, etc.) |
| ai_generated_tags | ARRAY | '{}'::text[] | YES | Tags generated by AI |
| manual_tags | ARRAY | | YES | Manually added tags |
| last_modified_at | timestamp with time zone | | YES | Last file modification time |
| last_indexed_at | timestamp with time zone | now() | YES | Last time file was indexed |
| file_hash | text | | YES | Hash of file contents |
| metadata | jsonb | '{}'::jsonb | NO | Additional metadata |
| created_at | timestamp with time zone | now() | NO | Record creation timestamp |
| updated_at | timestamp with time zone | now() | NO | Record update timestamp |
| is_deleted | boolean | false | NO | Deletion flag |
| script_type_id | uuid | | YES | Reference to script type |
| package_json_references | jsonb | '[]'::jsonb | YES | Package references |
| ai_assessment | jsonb | | YES | AI assessment data |
| assessment_quality_score | integer | | YES | Quality score |
| assessment_created_at | timestamp with time zone | | YES | Assessment creation time |
| assessment_updated_at | timestamp with time zone | | YES | Assessment update time |
| assessment_model | text | | YES | AI model used |
| assessment_version | integer | 1 | YES | Assessment version |
| assessment_date | date | | YES | Assessment date |
| document_type_id | uuid | | YES | Document type ID |

## Implementation Requirements

### 1. Script Files Structure

Create the following files:
- `scripts/cli-pipeline/script-manager.sh` - Core script management functionality
- `scripts/cli-pipeline/script-pipeline-main.sh` - Main pipeline script with command options

### 2. CLI Services Reuse

Reuse existing packages from the CLI services:
- `packages/cli/src/services/file-service.ts` - For file operations and discovery
- `packages/cli/src/services/file-management/file-discovery.ts` - For discovering new script files
- `packages/cli/src/services/prompt-query-service.ts` - For handling prompt relationships
- `packages/cli/src/services/prompt-document-classifier.ts` - For classification functionality
- `packages/cli/src/services/document-classification-service.ts` - For robust error handling during classification
- `packages/cli/src/services/claude-service.ts` - For AI integration
- `packages/cli/src/commands/scan-scripts.ts` - For script scanning operations
- `packages/cli/src/commands/analyze-script.ts` - For script analysis

### 3. Command Line Options

Implement the following options in `script-pipeline-main.sh`:

```
Usage: scripts/cli-pipeline/script-pipeline-main.sh [option] [count]
Options:
  sync                      - Synchronize database with files on disk (mark files as deleted/not deleted)
  find-new                  - Find and insert new script files on disk into the database
  show-untyped              - Show all script files without a script type
  show-recent               - Show the 20 most recent script files based on update date
  classify-recent           - Classify the 20 most recent script files
  classify-untyped [n]      - Classify untyped script files, optionally specify number to process (default: 10)
  generate-summary [n] [i]  - Generate a summary report of scripts
                              n: Number of scripts (default: 50, use 'all' for all scripts)
                              i: Include deleted (true/false, default: false)
  all                       - Run the complete pipeline (sync, find-new, classify-recent)
  help                      - Show this help message
```

## Implementation Steps

### 1. Setup and Verification

Before implementation, verify that all required services are present and working correctly:

```typescript
// Verification script - packages/cli/src/verify-dependencies.ts
import { FileService } from './services/file-service';
import { FileDiscoveryService } from './services/file-management/file-discovery';
import { PromptQueryService } from './services/prompt-query-service';
import { PromptDocumentClassifier } from './services/prompt-document-classifier';
import { DocumentClassificationService } from './services/document-classification-service';
import { ClaudeService } from './services/claude-service';
import { supabase } from './utils/supabase-client';

// Check that database connection works
async function verifySupabaseConnection(): Promise<boolean> {
  try {
    const { data, error } = await supabase.from('scripts').select('count(*)', { count: 'exact' });
    if (error) {
      console.error('Supabase connection error:', error);
      return false;
    }
    console.log('Supabase connection successful');
    return true;
  } catch (error) {
    console.error('Error verifying Supabase connection:', error);
    return false;
  }
}

// Verify that the script analysis prompt exists
async function verifyScriptAnalysisPrompt(): Promise<boolean> {
  try {
    const promptService = new PromptQueryService();
    const prompt = await promptService.getPromptByName('script-analysis-prompt');
    if (!prompt) {
      console.error('Error: script-analysis-prompt not found in the database');
      return false;
    }
    console.log('Script analysis prompt found:', prompt.name);
    return true;
  } catch (error) {
    console.error('Error verifying script analysis prompt:', error);
    return false;
  }
}

// Run all verifications
async function runVerifications(): Promise<boolean> {
  console.log('Verifying dependencies...');
  
  const checks = [
    { name: 'Supabase Connection', check: verifySupabaseConnection },
    { name: 'Script Analysis Prompt', check: verifyScriptAnalysisPrompt }
  ];
  
  let allPassed = true;
  
  for (const { name, check } of checks) {
    console.log(`\nVerifying ${name}...`);
    const passed = await check();
    if (!passed) {
      allPassed = false;
      console.error(`âœ– ${name} verification failed`);
    } else {
      console.log(`âœ“ ${name} verification passed`);
    }
  }
  
  if (!allPassed) {
    console.error('\nâŒ Some verifications failed. Please fix the issues before continuing.');
  } else {
    console.log('\nâœ… All verifications passed!');
  }
  
  return allPassed;
}

runVerifications().then(passed => {
  if (!passed) {
    process.exit(1);
  }
});
```

### 2. Script Type Definition Interface

Create a well-defined interface for script types to ensure consistency:

```typescript
// packages/cli/src/types/script-types.ts
export interface Script {
  id: string;
  file_path: string;
  title: string;
  summary: ScriptSummary | null;
  language: string;
  ai_generated_tags: string[];
  manual_tags: string[] | null;
  last_modified_at: string | null;
  last_indexed_at: string | null;
  file_hash: string | null;
  metadata: Record<string, any>;
  created_at: string;
  updated_at: string;
  is_deleted: boolean;
  script_type_id: string | null;
  package_json_references: PackageReference[] | null;
  ai_assessment: ScriptAssessment | null;
  assessment_quality_score: number | null;
  assessment_created_at: string | null;
  assessment_updated_at: string | null;
  assessment_model: string | null;
  assessment_version: number | null;
  assessment_date: string | null;
  document_type_id: string | null;
}

export interface ScriptSummary {
  description: string;
  purpose: string;
  dependencies?: string[];
  inputs?: string[];
  outputs?: string[];
  key_functions?: string[];
}

export interface PackageReference {
  name: string;
  version?: string;
  path?: string;
}

export interface ScriptAssessment {
  quality: 'high' | 'medium' | 'low';
  complexity: 'high' | 'medium' | 'low';
  security_issues?: string[];
  improvement_suggestions?: string[];
  documentation_quality?: 'high' | 'medium' | 'low';
  maintainability?: 'high' | 'medium' | 'low';
}

export interface ScriptTypeDefinition {
  id: string;
  name: string;
  description: string;
  created_at: string;
}

export interface ScriptFile {
  file_path: string;
  title: string;
  language: string;
  last_modified_at: string;
  file_hash: string;
}

export interface AIResponse {
  text: string;
  model: string;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

export interface ClassificationResult {
  scriptTypeId: string | null;
  summary: ScriptSummary | null;
  aiGeneratedTags: string[];
  aiAssessment: ScriptAssessment | null;
}

export interface SummaryOptions {
  limit: number;
  includeDeleted: boolean;
}
```

### 3. Script Management Service

Create a service specifically for script management, leveraging existing services:

```typescript
// packages/cli/src/services/script-management-service.ts
import { FileService } from './file-service';
import { FileDiscoveryService } from './file-management/file-discovery';
import { PromptQueryService } from './prompt-query-service';
import { ClaudeService } from './claude-service';
import { supabase } from '../utils/supabase-client';
import { createHash } from 'crypto';
import * as path from 'path';
import { promises as fs } from 'fs';
import {
  Script, 
  ScriptFile, 
  ClassificationResult,
  SummaryOptions
} from '../types/script-types';

export class ScriptManagementService {
  private fileService: FileService;
  private fileDiscoveryService: FileDiscoveryService;
  private promptQueryService: PromptQueryService;
  private claudeService: ClaudeService;
  private readonly scriptExtensions = ['.sh', '.js'];
  private readonly excludeDirs = ['node_modules', '.git', 'dist', 'build'];
  
  constructor() {
    this.fileService = new FileService();
    this.fileDiscoveryService = new FileDiscoveryService();
    this.promptQueryService = new PromptQueryService();
    this.claudeService = new ClaudeService();
  }
  
  /**
   * Discovers script files in the given directory
   * @param rootDir - Root directory to scan
   * @returns Array of discovered script files
   */
  async discoverScripts(rootDir: string): Promise<ScriptFile[]> {
    console.log(`Discovering scripts in ${rootDir}...`);
    
    try {
      const scripts: ScriptFile[] = [];
      
      // Use file discovery service to scan directories
      const scriptPatterns = this.scriptExtensions.map(ext => `**/*${ext}`);
      const scriptPaths = await this.fileService.findFiles({
        patterns: scriptPatterns,
        exclude: this.excludeDirs,
        cwd: rootDir
      });
      
      // Process each discovered script file
      for (const scriptPath of scriptPaths) {
        const fullPath = path.resolve(rootDir, scriptPath);
        const stats = await fs.stat(fullPath);
        const content = await this.fileService.readFile(fullPath);
        
        if (!content.success) {
          console.warn(`Failed to read script file: ${fullPath}`);
          continue;
        }
        
        const hash = this.generateHash(content.data);
        
        scripts.push({
          file_path: fullPath,
          title: path.basename(fullPath),
          language: path.extname(fullPath) === '.sh' ? 'bash' : 'javascript',
          last_modified_at: stats.mtime.toISOString(),
          file_hash: hash
        });
      }
      
      console.log(`Discovered ${scripts.length} script files`);
      return scripts;
    } catch (error) {
      console.error(`Error discovering scripts:`, error);
      throw new Error(`Failed to discover scripts: ${error.message}`);
    }
  }
  
  /**
   * Generates a hash for file content
   * @param content - File content
   * @returns MD5 hash of the content
   */
  private generateHash(content: string): string {
    return createHash('md5').update(content).digest('hex');
  }
  
  /**
   * Synchronizes database with discovered script files
   * @param scripts - Discovered script files
   * @returns Result of the synchronization
   */
  async syncWithDatabase(scripts: ScriptFile[]): Promise<{
    added: number;
    updated: number;
    deleted: number;
    errors: number;
  }> {
    console.log("Synchronizing scripts with database...");
    
    const result = {
      added: 0,
      updated: 0,
      deleted: 0,
      errors: 0
    };
    
    try {
      // Get existing scripts from database
      const { data: dbScripts, error } = await supabase
        .from('scripts')
        .select('id, file_path, file_hash')
        .eq('is_deleted', false);
      
      if (error) {
        console.error("Error fetching scripts from database:", error);
        throw new Error(`Failed to fetch scripts from database: ${error.message}`);
      }
      
      // Create map and set for efficient lookups
      const dbScriptMap = new Map(dbScripts.map(script => [script.file_path, script]));
      const diskScriptPaths = new Set(scripts.map(script => script.file_path));
      
      // Mark scripts that no longer exist as deleted
      const toDelete = dbScripts.filter(dbScript => !diskScriptPaths.has(dbScript.file_path));
      
      if (toDelete.length > 0) {
        console.log(`Marking ${toDelete.length} scripts as deleted...`);
        const { error: deleteError } = await supabase
          .from('scripts')
          .update({ is_deleted: true, updated_at: new Date().toISOString() })
          .in('id', toDelete.map(script => script.id));
        
        if (deleteError) {
          console.error("Error marking scripts as deleted:", deleteError);
          result.errors += toDelete.length;
        } else {
          result.deleted = toDelete.length;
        }
      }
      
      // Process each script for insert or update
      for (const script of scripts) {
        const dbScript = dbScriptMap.get(script.file_path);
        
        if (dbScript) {
          // Update existing script if hash changed
          if (dbScript.file_hash !== script.file_hash) {
            console.log(`Updating script: ${script.file_path}`);
            const { error: updateError } = await supabase
              .from('scripts')
              .update({
                last_modified_at: script.last_modified_at,
                file_hash: script.file_hash,
                updated_at: new Date().toISOString(),
                is_deleted: false
              })
              .eq('id', dbScript.id);
            
            if (updateError) {
              console.error(`Error updating script ${script.file_path}:`, updateError);
              result.errors++;
            } else {
              result.updated++;
            }
          }
        } else {
          // Insert new script
          console.log(`Inserting new script: ${script.file_path}`);
          const { error: insertError } = await supabase
            .from('scripts')
            .insert({
              ...script,
              metadata: {},
              last_indexed_at: new Date().toISOString()
            });
          
          if (insertError) {
            console.error(`Error inserting script ${script.file_path}:`, insertError);
            result.errors++;
          } else {
            result.added++;
          }
        }
      }
      
      console.log("Script synchronization complete.");
      console.log(`Summary: Added=${result.added}, Updated=${result.updated}, Deleted=${result.deleted}, Errors=${result.errors}`);
      return result;
    } catch (error) {
      console.error("Error during script synchronization:", error);
      throw new Error(`Failed to synchronize scripts: ${error.message}`);
    }
  }
  
  /**
   * Classifies a script using the AI service
   * @param filePath - Path to the script file
   * @returns Classification result
   */
  async classifyScript(filePath: string): Promise<ClassificationResult | null> {
    console.log(`Classifying script: ${filePath}`);
    
    try {
      // Verify file exists
      const fileExists = await this.fileService.fileExists(filePath);
      if (!fileExists) {
        throw new Error(`Script file not found: ${filePath}`);
      }
      
      // Read file content
      const fileResult = await this.fileService.readFile(filePath);
      if (!fileResult.success) {
        throw new Error(`Failed to read script file: ${filePath}`);
      }
      
      // Get script analysis prompt
      const prompt = await this.promptQueryService.getPromptByName('script-analysis-prompt');
      if (!prompt) {
        throw new Error("Script analysis prompt not found in database");
      }
      
      // Prepare prompt with script content
      const scriptContent = fileResult.data;
      const fullPrompt = prompt.content
        .replace('{{SCRIPT_CONTENT}}', scriptContent)
        .replace('{{FILE_PATH}}', filePath);
      
      // Call Claude API
      console.log(`Calling Claude API for script analysis...`);
      const response = await this.claudeService.callClaudeApi({
        prompt: fullPrompt,
        temperature: 0,
        max_tokens: 4000,
        model: 'claude-3-7-sonnet-20250219'
      });
      
      if (!response || !response.completion) {
        throw new Error("Empty response from Claude API");
      }
      
      // Parse the AI response
      console.log(`Parsing AI response...`);
      const result = this.parseAIResponse(response.completion);
      
      console.log(`Classification complete for ${filePath}`);
      return result;
    } catch (error) {
      console.error(`Error classifying script ${filePath}:`, error);
      return null;
    }
  }
  
  /**
   * Parses AI response into structured data
   * @param aiResponse - AI response text
   * @returns Structured classification result
   */
  private parseAIResponse(aiResponse: string): ClassificationResult {
    try {
      // Look for JSON response in the AI output
      const jsonMatch = aiResponse.match(/```json([\s\S]*?)```/);
      if (jsonMatch && jsonMatch[1]) {
        const jsonStr = jsonMatch[1].trim();
        const parsedResult = JSON.parse(jsonStr);
        
        return {
          scriptTypeId: parsedResult.script_type_id || null,
          summary: parsedResult.summary || null,
          aiGeneratedTags: parsedResult.tags || [],
          aiAssessment: parsedResult.assessment || null
        };
      }
      
      // Fallback parsing if JSON not found
      console.warn("JSON not found in AI response, using fallback parsing");
      
      // Extract tags (look for lines with "Tags:" or similar)
      const tagMatch = aiResponse.match(/Tags:(.+)$/m);
      const tags = tagMatch ? 
        tagMatch[1].split(',').map(tag => tag.trim()).filter(Boolean) : 
        [];
      
      // Extract summary (first paragraph)
      const summaryMatch = aiResponse.match(/^(.+?)(?:\n\n|\n$)/);
      const summary = summaryMatch ? 
        { description: summaryMatch[1].trim(), purpose: '' } : 
        null;
      
      return {
        scriptTypeId: null,
        summary,
        aiGeneratedTags: tags,
        aiAssessment: null
      };
    } catch (error) {
      console.error("Error parsing AI response:", error);
      return {
        scriptTypeId: null,
        summary: null,
        aiGeneratedTags: [],
        aiAssessment: null
      };
    }
  }
  
  /**
   * Updates a script in the database with classification results
   * @param scriptId - Script ID
   * @param result - Classification result
   * @returns Success status
   */
  async updateScriptWithClassification(scriptId: string, result: ClassificationResult): Promise<boolean> {
    console.log(`Updating script ${scriptId} with classification results`);
    
    try {
      const now = new Date().toISOString();
      
      const { error } = await supabase
        .from('scripts')
        .update({
          script_type_id: result.scriptTypeId,
          summary: result.summary,
          ai_generated_tags: result.aiGeneratedTags,
          ai_assessment: result.aiAssessment,
          assessment_created_at: now,
          assessment_updated_at: now,
          assessment_model: 'claude-3-7-sonnet-20250219',
          assessment_version: 1,
          assessment_date: now.split('T')[0],
          updated_at: now
        })
        .eq('id', scriptId);
      
      if (error) {
        console.error(`Error updating script ${scriptId} with classification:`, error);
        return false;
      }
      
      console.log(`Successfully updated script ${scriptId} with classification results`);
      return true;
    } catch (error) {
      console.error(`Error updating script with classification:`, error);
      return false;
    }
  }
  
  /**
   * Gets untyped scripts from the database
   * @param limit - Maximum number of scripts to retrieve
   * @returns Array of untyped scripts
   */
  async getUntypedScripts(limit: number): Promise<Script[]> {
    console.log(`Getting up to ${limit} untyped scripts...`);
    
    try {
      const { data, error } = await supabase
        .from('scripts')
        .select('id, file_path, title, language')
        .is('script_type_id', null)
        .eq('is_deleted', false)
        .order('created_at', { ascending: false })
        .limit(limit);
      
      if (error) {
        console.error("Error fetching untyped scripts:", error);
        return [];
      }
      
      console.log(`Found ${data.length} untyped scripts`);
      return data || [];
    } catch (error) {
      console.error("Error getting untyped scripts:", error);
      return [];
    }
  }
  
  /**
   * Gets recent scripts from the database
   * @param limit - Maximum number of scripts to retrieve
   * @returns Array of recent scripts
   */
  async getRecentScripts(limit: number): Promise<Script[]> {
    console.log(`Getting up to ${limit} recent scripts...`);
    
    try {
      const { data, error } = await supabase
        .from('scripts')
        .select('id, file_path, title, language, updated_at')
        .eq('is_deleted', false)
        .order('updated_at', { ascending: false })
        .limit(limit);
      
      if (error) {
        console.error("Error fetching recent scripts:", error);
        return [];
      }
      
      console.log(`Found ${data.length} recent scripts`);
      return data || [];
    } catch (error) {
      console.error("Error getting recent scripts:", error);
      return [];
    }
  }
  
  /**
   * Removes script analysis results from the database
   * @returns Success status
   */
  async cleanScriptResults(): Promise<boolean> {
    console.log("Cleaning script analysis results...");
    
    try {
      const { error } = await supabase
        .from('scripts')
        .update({
          ai_assessment: null,
          assessment_quality_score: null,
          assessment_created_at: null,
          assessment_updated_at: null,
          assessment_model: null,
          assessment_date: null
        })
        .is('ai_assessment', 'not.null');
      
      if (error) {
        console.error("Error cleaning script results:", error);
        return false;
      }
      
      console.log("Script results cleaning completed successfully");
      return true;
    } catch (error) {
      console.error("Error cleaning script results:", error);
      return false;
    }
  }
  
  /**
   * Generates a summary report of scripts
   * @param options - Summary options
   * @returns Path to the generated report
   */
  async generateSummary(options: SummaryOptions): Promise<string | null> {
    console.log(`Generating summary for ${options.limit === -1 ? 'all' : options.limit} scripts (include deleted: ${options.includeDeleted})`);
    
    try {
      // Fetch scripts from the database
      let query = supabase
        .from('scripts')
        .select(`
          id, 
          file_path, 
          title, 
          language, 
          summary,
          ai_generated_tags,
          script_type_id,
          created_at,
          updated_at,
          is_deleted
        `);
      
      if (!options.includeDeleted) {
        query = query.eq('is_deleted', false);
      }
      
      if (options.limit !== -1) {
        query = query.limit(options.limit);
      }
      
      query = query.order('updated_at', { ascending: false });
      
      const { data: scripts, error } = await query;
      
      if (error) {
        throw error;
      }
      
      // Verify we have scripts to process
      if (!scripts || scripts.length === 0) {
        console.log("No scripts found for summary report");
        return null;
      }
      
      // Generate the report
      let report = `# Script Summary Report\n\n`;
      report += `Generated: ${new Date().toISOString()}\n`;
      report += `Total Scripts: ${scripts.length}\n\n`;
      
      // Group by script type
      const scriptsByType = this.groupByScriptType(scripts);
      
      // Generate the report sections
      for (const [typeId, typeScripts] of Object.entries(scriptsByType)) {
        // Get type name if possible
        let typeName = 'Unclassified';
        
        if (typeId !== 'null') {
          const { data } = await supabase
            .from('script_types')
            .select('name')
            .eq('id', typeId)
            .single();
          
          if (data && data.name) {
            typeName = data.name;
          }
        }
        
        report += `## ${typeName} (${typeScripts.length})\n\n`;
        
        for (const script of typeScripts) {
          report += `### ${script.title}\n`;
          report += `- Path: ${script.file_path}\n`;
          report += `- Language: ${script.language}\n`;
          
          if (script.ai_generated_tags && script.ai_generated_tags.length > 0) {
            report += `- Tags: ${script.ai_generated_tags.join(', ')}\n`;
          }
          
          if (script.summary) {
            if (typeof script.summary === 'object') {
              report += `- Description: ${script.summary.description || 'N/A'}\n`;
              report += `- Purpose: ${script.summary.purpose || 'N/A'}\n`;
              
              if (script.summary.key_functions && script.summary.key_functions.length > 0) {
                report += `- Key Functions: ${script.summary.key_functions.join(', ')}\n`;
              }
            } else {
              report += `- Summary: ${JSON.stringify(script.summary)}\n`;
            }
          }
          
          report += `- Created: ${script.created_at}\n`;
          report += `- Updated: ${script.updated_at}\n`;
          
          if (script.is_deleted) {
            report += `- Status: Deleted\n`;
          }
          
          report += `\n`;
        }
      }
      
      // Create reports directory if it doesn't exist
      const reportsDir = 'reports';
      try {
        await fs.mkdir(reportsDir, { recursive: true });
      } catch (mkdirError) {
        console.error(`Error creating reports directory: ${mkdirError.message}`);
      }
      
      // Write the report to a file
      const reportPath = `${reportsDir}/script-summary-${new Date().toISOString().slice(0, 10)}.md`;
      await fs.writeFile(reportPath, report);
      
      console.log(`Summary report generated: ${reportPath}`);
      return reportPath;
    } catch (error) {
      console.error("Error generating script summary:", error);
      return null;
    }
  }
  
  /**
   * Groups scripts by their script type
   * @param scripts - Array of scripts
   * @returns Map of script type to scripts
   */
  private groupByScriptType(scripts: Script[]): Record<string, Script[]> {
    const result: Record<string, Script[]> = {};
    
    for (const script of scripts) {
      const typeId = script.script_type_id || 'null';
      if (!result[typeId]) {
        result[typeId] = [];
      }
      result[typeId].push(script);
    }
    
    return result;
  }
}
```

### 4. CLI Command Implementation

Create a new script commands class that integrates with the existing CLI structure:

```typescript
// packages/cli/src/commands/script-commands.ts
import { Command } from 'commander';
import { ScriptManagementService } from '../services/script-management-service';
import { promises as fs } from 'fs';
import * as path from 'path';

export function registerScriptCommands(program: Command): void {
  const scriptService = new ScriptManagementService();
  
  // Command to sync scripts
  program
    .command('script-sync')
    .description('Synchronize database with script files on disk')
    .action(async () => {
      try {
        console.log("Starting script sync process...");
        const scripts = await scriptService.discoverScripts(process.cwd());
        
        if (scripts.length === 0) {
          console.log("No script files found.");
          return;
        }
        
        const result = await scriptService.syncWithDatabase(scripts);
        console.log("Script sync completed successfully.");
        console.log(`Summary: Added=${result.added}, Updated=${result.updated}, Deleted=${result.deleted}, Errors=${result.errors}`);
      } catch (error) {
        console.error("Error during script sync:", error);
        process.exit(1);
      }
    });
  
  // Command to find new scripts
  program
    .command('script-find-new')
    .description('Find and insert new script files')
    .action(async () => {
      try {
        console.log("Looking for new script files...");
        const scripts = await scriptService.discoverScripts(process.cwd());
        
        if (scripts.length === 0) {
          console.log("No script files found.");
          return;
        }
        
        const result = await scriptService.syncWithDatabase(scripts);
        console.log(`New script discovery completed. Added ${result.added} new scripts.`);
      } catch (error) {
        console.error("Error finding new scripts:", error);
        process.exit(1);
      }
    });
  
  // Command to show untyped scripts
  program
    .command('script-show-untyped')
    .description('Show scripts without a script type')
    .action(async () => {
      try {
        const scripts = await scriptService.getUntypedScripts(100);
        
        if (scripts.length === 0) {
          console.log("No untyped scripts found.");
          return;
        }
        
        console.log("Untyped Scripts:");
        scripts.forEach((script, index) => {
          console.log(`${index + 1}. ${script.file_path} (ID: ${script.id})`);
        });
        console.log(`Total: ${scripts.length} untyped scripts found.`);
      } catch (error) {
        console.error("Error showing untyped scripts:", error);
        process.exit(1);
      }
    });
  
  // Command to show recent scripts
  program
    .command('script-show-recent')
    .description('Show recent scripts')
    .action(async () => {
      try {
        const scripts = await scriptService.getRecentScripts(20);
        
        if (scripts.length === 0) {
          console.log("No scripts found.");
          return;
        }
        
        console.log("Recent Scripts:");
        scripts.forEach((script, index) => {
          console.log(`${index + 1}. ${script.file_path} (Updated: ${script.updated_at})`);
        });
      } catch (error) {
        console.error("Error showing recent scripts:", error);
        process.exit(1);
      }
    });
  
  // Command to classify recent scripts
  program
    .command('script-classify-recent')
    .description('Classify recent scripts')
    .action(async () => {
      try {
        const scripts = await scriptService.getRecentScripts(20);
        
        if (scripts.length === 0) {
          console.log("No scripts found for classification.");
          return;
        }
        
        console.log(`Processing ${scripts.length} recent scripts for classification...`);
        
        let success = 0;
        let failure = 0;
        
        for (const script of scripts) {
          try {
            console.log(`Processing: ${script.file_path}`);
            
            // Verify file exists
            if (!await fs.access(script.file_path).then(() => true).catch(() => false)) {
              console.warn(`File not found: ${script.file_path}`);
              failure++;
              continue;
            }
            
            const result = await scriptService.classifyScript(script.file_path);
            
            if (!result) {
              console.warn(`Classification failed for: ${script.file_path}`);
              failure++;
              continue;
            }
            
            const updated = await scriptService.updateScriptWithClassification(script.id, result);
            
            if (updated) {
              success++;
            } else {
              failure++;
            }
          } catch (scriptError) {
            console.error(`Error processing script ${script.file_path}:`, scriptError);
            failure++;
          }
        }
        
        console.log(`Classification of recent scripts completed: ${success} successful, ${failure} failed.`);
      } catch (error) {
        console.error("Error classifying recent scripts:", error);
        process.exit(1);
      }
    });
  
  // Command to classify untyped scripts
  program
    .command('script-classify-untyped')
    .description('Classify untyped scripts')
    .option('--count <number>', 'Number of scripts to process', '10')
    .action(async (options) => {
      try {
        const count = parseInt(options.count, 10);
        
        if (isNaN(count) || count <= 0) {
          console.error("Invalid count parameter. Please provide a positive integer.");
          process.exit(1);
        }
        
        const scripts = await scriptService.getUntypedScripts(count);
        
        if (scripts.length === 0) {
          console.log("No untyped scripts found for classification.");
          return;
        }
        
        console.log(`Processing ${scripts.length} untyped scripts for classification...`);
        
        let success = 0;
        let failure = 0;
        
        for (const script of scripts) {
          try {
            console.log(`Processing: ${script.file_path}`);
            
            // Verify file exists
            if (!await fs.access(script.file_path).then(() => true).catch(() => false)) {
              console.warn(`File not found: ${script.file_path}`);
              failure++;
              continue;
            }
            
            const result = await scriptService.classifyScript(script.file_path);
            
            if (!result) {
              console.warn(`Classification failed for: ${script.file_path}`);
              failure++;
              continue;
            }
            
            const updated = await scriptService.updateScriptWithClassification(script.id, result);
            
            if (updated) {
              success++;
            } else {
              failure++;
            }
          } catch (scriptError) {
            console.error(`Error processing script ${script.file_path}:`, scriptError);
            failure++;
          }
        }
        
        console.log(`Classification of untyped scripts completed: ${success} successful, ${failure} failed.`);
      } catch (error) {
        console.error("Error classifying untyped scripts:", error);
        process.exit(1);
      }
    });
  
  
  // Command to generate summary
  program
    .command('script-generate-summary')
    .description('Generate a summary report of scripts')
    .option('--count <number>', 'Number of scripts', '50')
    .option('--include-deleted <boolean>', 'Include deleted scripts', 'false')
    .action(async (options) => {
      try {
        let count: number;
        if (options.count === 'all') {
          count = -1;
        } else {
          count = parseInt(options.count, 10);
          if (isNaN(count) || count < 1) {
            console.error("Invalid count parameter. Please provide a positive integer or 'all'.");
            process.exit(1);
          }
        }
        
        const includeDeleted = options.includeDeleted === 'true';
        
        const reportPath = await scriptService.generateSummary({
          limit: count,
          includeDeleted
        });
        
        if (reportPath) {
          console.log(`Summary report generated successfully: ${reportPath}`);
        } else {
          console.error("Failed to generate summary report.");
          process.exit(1);
        }
      } catch (error) {
        console.error("Error generating summary:", error);
        process.exit(1);
      }
    });
}
```

### 5. Register Commands in CLI Main

Update the CLI main file to register the script commands:

```typescript
// packages/cli/src/cli.ts
import { program } from 'commander';
import { registerDocumentCommands } from './commands/document-commands';
import { registerScriptCommands } from './commands/script-commands';
// Import other command modules

// Setup program information
program
  .name('cli')
  .description('CLI for managing documentation and scripts')
  .version('1.0.0');

// Register all command modules
registerDocumentCommands(program);
registerScriptCommands(program); // Add script commands
// Register other command modules

// Parse command line arguments
program.parse(process.argv);

// Handle case when no commands are provided
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
```

### 6. Shell Scripts Implementation

#### 6.1 script-manager.sh

Create the script manager shell script:

```bash
#!/bin/bash
# script-manager.sh - Core script management functionality

# Set environment variables (source relevant environment files if needed)
export NODE_ENV="${NODE_ENV:-development}"

# Define paths and directories
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
CLI_DIR="${ROOT_DIR}/packages/cli"
SCRIPT_REPORTS_DIR="${ROOT_DIR}/script-analysis-results"

# Create reports directory if it doesn't exist
mkdir -p "${SCRIPT_REPORTS_DIR}"

# Log configuration
LOG_FILE="${SCRIPT_REPORTS_DIR}/script-pipeline-$(date +%Y-%m-%d_%H-%M-%S).log"
exec > >(tee -a "${LOG_FILE}") 2>&1

# Check if CLI is built
if [ ! -f "${CLI_DIR}/dist/cli.js" ]; then
  echo "Error: CLI not built. Building CLI..."
  cd "${CLI_DIR}" && npm run build
  
  # Verify build was successful
  if [ ! -f "${CLI_DIR}/dist/cli.js" ]; then
    echo "Error: Failed to build CLI. Exiting."
    exit 1
  fi
fi

# Function to synchronize database with files on disk
function sync_scripts() {
  echo "ðŸ”„ Syncing scripts database with files on disk..."
  node "${CLI_DIR}/dist/cli.js" script-sync
  
  # Check for success
  if [ $? -ne 0 ]; then
    echo "âŒ Script sync failed!"
    return 1
  fi
  
  echo "âœ… Script sync completed successfully"
  return 0
}

# Function to find and insert new script files
function find_new_scripts() {
  echo "ðŸ” Finding new script files..."
  node "${CLI_DIR}/dist/cli.js" script-find-new
  
  # Check for success
  if [ $? -ne 0 ]; then
    echo "âŒ Finding new scripts failed!"
    return 1
  fi
  
  echo "âœ… New script discovery completed successfully"
  return 0
}

# Function to show untyped scripts
function show_untyped_scripts() {
  echo "ðŸ“‹ Showing untyped scripts..."
  node "${CLI_DIR}/dist/cli.js" script-show-untyped
  
  # Check for success
  if [ $? -ne 0 ]; then
    echo "âŒ Showing untyped scripts failed!"
    return 1
  fi
  
  return 0
}

# Function to show recent scripts
function show_recent_scripts() {
  echo "ðŸ“‹ Showing recent scripts..."
  node "${CLI_DIR}/dist/cli.js" script-show-recent
  
  # Check for success
  if [ $? -ne 0 ]; then
    echo "âŒ Showing recent scripts failed!"
    return 1
  fi
  
  return 0
}

# Function to classify recent scripts
function classify_recent_scripts() {
  echo "ðŸ§  Classifying recent scripts..."
  node "${CLI_DIR}/dist/cli.js" script-classify-recent
  
  # Check for success
  if [ $? -ne 0 ]; then
    echo "âŒ Classifying recent scripts failed!"
    return 1
  fi
  
  echo "âœ… Classification of recent scripts completed successfully"
  return 0
}

# Function to classify untyped scripts
function classify_untyped_scripts() {
  local count=${1:-10}
  echo "ðŸ§  Classifying ${count} untyped scripts..."
  node "${CLI_DIR}/dist/cli.js" script-classify-untyped --count "${count}"
  
  # Check for success
  if [ $? -ne 0 ]; then
    echo "âŒ Classifying untyped scripts failed!"
    return 1
  fi
  
  echo "âœ… Classification of untyped scripts completed successfully"
  return 0
}


# Function to generate summary report
function generate_summary() {
  local count=${1:-50}
  local include_deleted=${2:-false}
  echo "ðŸ“Š Generating summary report for ${count} scripts (include deleted: ${include_deleted})..."
  node "${CLI_DIR}/dist/cli.js" script-generate-summary --count "${count}" --include-deleted "${include_deleted}"
  
  # Check for success
  if [ $? -ne 0 ]; then
    echo "âŒ Generating summary report failed!"
    return 1
  fi
  
  echo "âœ… Summary report generation completed successfully"
  return 0
}

# Function to run the complete pipeline
function run_complete_pipeline() {
  echo "ðŸš€ Running complete script pipeline..."
  local success=true
  
  sync_scripts
  if [ $? -ne 0 ]; then
    success=false
  fi
  
  find_new_scripts
  if [ $? -ne 0 ]; then
    success=false
  fi
  
  classify_recent_scripts
  if [ $? -ne 0 ]; then
    success=false
  fi
  
  if [ "$success" = true ]; then
    echo "âœ… Complete pipeline executed successfully"
    return 0
  else
    echo "âš ï¸ Pipeline completed with errors"
    return 1
  fi
}

# Export all functions
export -f sync_scripts
export -f find_new_scripts
export -f show_untyped_scripts
export -f show_recent_scripts
export -f classify_recent_scripts
export -f classify_untyped_scripts
export -f clean_script_results
export -f generate_summary
export -f run_complete_pipeline
```

#### 6.2 script-pipeline-main.sh

Create the main pipeline shell script:

```bash
#!/bin/bash
# script-pipeline-main.sh - Main pipeline for managing scripts

# Source the script manager (with error handling)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MANAGER_SCRIPT="${SCRIPT_DIR}/script-manager.sh"

if [ ! -f "${MANAGER_SCRIPT}" ]; then
  echo "Error: Cannot find script-manager.sh at ${MANAGER_SCRIPT}"
  exit 1
fi

source "${MANAGER_SCRIPT}"

# Display usage information
function show_help() {
  echo "Usage: scripts/cli-pipeline/script-pipeline-main.sh [option] [count]"
  echo "Options:"
  echo "  sync                      - Synchronize database with files on disk (mark files as deleted/not deleted)"
  echo "  find-new                  - Find and insert new script files on disk into the database"
  echo "  show-untyped              - Show all script files without a script type"
  echo "  show-recent               - Show the 20 most recent script files based on update date"
  echo "  classify-recent           - Classify the 20 most recent script files"
  echo "  classify-untyped [n]      - Classify untyped script files, optionally specify number to process (default: 10)"
  echo "  generate-summary [n] [i]  - Generate a summary report of scripts"
  echo "                              n: Number of scripts (default: 50, use 'all' for all scripts)"
  echo "                              i: Include deleted (true/false, default: false)"
  echo "  all                       - Run the complete pipeline (sync, find-new, classify-recent)"
  echo "  help                      - Show this help message"
}

# Check for required environment variables
if [ -z "${SUPABASE_URL}" ] || [ -z "${SUPABASE_KEY}" ]; then
  echo "âš ï¸ Warning: SUPABASE_URL and/or SUPABASE_KEY environment variables not set."
  echo "    Some commands may fail without proper database credentials."
fi

# Main logic
option=$1
count=$2
include_deleted=$3

# Process command line options with input validation
case $option in
  sync)
    sync_scripts
    exit $?
    ;;
  find-new)
    find_new_scripts
    exit $?
    ;;
  show-untyped)
    show_untyped_scripts
    exit $?
    ;;
  show-recent)
    show_recent_scripts
    exit $?
    ;;
  classify-recent)
    classify_recent_scripts
    exit $?
    ;;
  classify-untyped)
    # Validate count parameter
    if [[ -n "$count" && ! "$count" =~ ^[0-9]+$ ]]; then
      echo "Error: Count must be a positive integer"
      exit 1
    fi
    classify_untyped_scripts "$count"
    exit $?
    ;;
  generate-summary)
    # Validate parameters
    if [[ -n "$count" && "$count" != "all" && ! "$count" =~ ^[0-9]+$ ]]; then
      echo "Error: Count must be a positive integer or 'all'"
      exit 1
    fi
    
    if [[ -n "$include_deleted" && "$include_deleted" != "true" && "$include_deleted" != "false" ]]; then
      echo "Error: Include deleted must be 'true' or 'false'"
      exit 1
    fi
    
    # Handle 'all' as a special case for count
    if [ "$count" = "all" ]; then
      count=-1
    fi
    
    generate_summary "$count" "$include_deleted"
    exit $?
    ;;
  all)
    run_complete_pipeline
    exit $?
    ;;
  help|"")
    show_help
    exit 0
    ;;
  *)
    echo "Error: Unknown option '$option'"
    show_help
    exit 1
    ;;
esac
```

## Testing Strategy

### 1. Unit Testing

Create comprehensive unit tests for the script management service:

```typescript
// packages/cli/src/tests/script-management-service.test.ts
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ScriptManagementService } from '../services/script-management-service';
import { supabase } from '../utils/supabase-client';
import { FileService } from '../services/file-service';
import * as fs from 'fs';
import * as path from 'path';

describe('ScriptManagementService', () => {
  let service: ScriptManagementService;
  let sandbox: sinon.SinonSandbox;
  
  beforeEach(() => {
    sandbox = sinon.createSandbox();
    service = new ScriptManagementService();
  });
  
  afterEach(() => {
    sandbox.restore();
  });
  
  describe('discoverScripts', () => {
    it('should discover script files in a directory', async () => {
      // Mock implementation
      // ...
    });
    
    it('should handle errors during discovery', async () => {
      // Mock implementation
      // ...
    });
  });
  
  describe('syncWithDatabase', () => {
    it('should sync script files with the database', async () => {
      // Mock implementation
      // ...
    });
    
    it('should handle database errors', async () => {
      // Mock implementation
      // ...
    });
  });
  
  // Additional tests for other methods
  // ...
});
```

### 2. Integration Testing

Create integration tests for the script pipeline:

```bash
#!/bin/bash
# tests/integration/test-script-pipeline.sh

# Set up test environment
echo "Setting up test environment..."
TEST_DIR=$(mktemp -d)
mkdir -p "$TEST_DIR/scripts"

# Create test scripts
echo "#!/bin/bash\necho 'Test script 1'" > "$TEST_DIR/scripts/test1.sh"
echo "console.log('Test script 2');" > "$TEST_DIR/scripts/test2.js"

# Mock database (if needed)
# ...

# Run the pipeline components
echo "Testing script sync..."
./scripts/cli-pipeline/script-pipeline-main.sh sync

# Check results
if [ $? -ne 0 ]; then
  echo "Test failed: Script sync command returned error"
  exit 1
fi

# Test finding new scripts
echo "Testing find-new..."
./scripts/cli-pipeline/script-pipeline-main.sh find-new

# Check results
if [ $? -ne 0 ]; then
  echo "Test failed: Find-new command returned error"
  exit 1
fi

# Clean up
echo "Cleaning up test environment..."
rm -rf "$TEST_DIR"

echo "All tests passed!"
```

## Verification and Error Handling

### 1. Pre-Implementation Verification

Before starting implementation, run the dependency verification script to ensure all required services are available:

```bash
# Verify dependencies
node packages/cli/dist/verify-dependencies.js

# Only proceed if verification passes
if [ $? -ne 0 ]; then
  echo "Dependency verification failed. Please fix the issues before continuing."
  exit 1
fi
```

### 2. Error Handling and Logging

Implement robust error handling throughout the codebase:

1. Use try/catch blocks around all async operations
2. Log detailed error information
3. Return appropriate error codes from shell scripts
4. Check for successful completion of each step before proceeding to the next
5. Create a detailed log file for each pipeline run
6. Validate all input parameters before use

### 3. Step-by-Step Validation

For each major operation, verify successful completion before moving to the next step:

```typescript
async function runClassificationPipeline(): Promise<boolean> {
  // Step 1: Get scripts to process
  const scripts = await getScriptsForClassification();
  if (!scripts || scripts.length === 0) {
    console.log("No scripts found for classification.");
    return true; // Not an error, just nothing to do
  }
  
  // Step 2: Process each script
  let successCount = 0;
  let errorCount = 0;
  
  for (const script of scripts) {
    try {
      console.log(`Processing script: ${script.file_path}`);
      
      // Step 2.1: Verify file exists
      if (!await fileExists(script.file_path)) {
        console.warn(`File not found: ${script.file_path}`);
        errorCount++;
        continue;
      }
      
      // Step 2.2: Classify script
      const result = await classifyScript(script.file_path);
      if (!result) {
        console.warn(`Classification failed for: ${script.file_path}`);
        errorCount++;
        continue;
      }
      
      // Step 2.3: Update database
      const updated = await updateDatabase(script.id, result);
      if (!updated) {
        console.warn(`Database update failed for: ${script.file_path}`);
        errorCount++;
        continue;
      }
      
      successCount++;
    } catch (error) {
      console.error(`Error processing script ${script.file_path}:`, error);
      errorCount++;
    }
  }
  
  // Report results
  console.log(`Classification completed: ${successCount} successful, ${errorCount} failed.`);
  return errorCount === 0;
}
```

## Deployment Plan

### 1. Development Phase

1. Create the TypeScript interfaces in `packages/cli/src/types/script-types.ts`
2. Implement the `ScriptManagementService` class with proper error handling
3. Create the CLI commands in `packages/cli/src/commands/script-commands.ts`
4. Update the main CLI file to register the script commands
5. Build and test the TypeScript implementation

### 2. Shell Script Phase

1. Create the shell scripts in `scripts/cli-pipeline/`
2. Set appropriate permissions with `chmod +x`
3. Test with basic command line calls

### 3. Integration Testing

1. Run the complete pipeline with test data
2. Verify correct operation with different script types and edge cases
3. Test error handling and recovery

### 4. Documentation

1. Update project documentation
2. Add usage examples
3. Provide troubleshooting guidance

## Critical Implementation Requirements

### 1. TypeScript Validation Requirements

**CRITICAL: You MUST verify all TypeScript code compiles without errors before submitting changes.**

For every code change:

1. **Compile and verify** TypeScript code in strict mode before considering it complete:
   ```bash
   cd packages/cli
   npm run build
   # or 
   tsc --noEmit --strict
   ```

2. **Add proper types to all**:
   - Function parameters
   - Return values
   - Variables and properties
   - API responses (especially from Supabase)

3. **Examine existing code** for patterns and type definitions:
   - Study similar services in `packages/cli/src/services`
   - Reuse existing type definitions whenever possible
   - Follow existing patterns for handling Supabase responses

4. **Add comprehensive JSDoc comments** to all public methods and functions

After implementation, run a final type check over the entire project with:
```bash
npm run typecheck
```

**Note:** Adding proper TypeScript types from the beginning prevents most errors that would require refactoring later. DO NOT submit code that doesn't pass TypeScript compilation.

### 2. Supabase Integration Requirements

To avoid Supabase errors:

1. **Study existing services** that use Supabase:
   - Examine `packages/cli/src/services/document-service.ts` 
   - Review `packages/cli/src/services/file-management/file-indexer.ts`
   - Look at other database interaction patterns in the codebase

2. **Use proper typing for Supabase queries**:
   - Leverage the `PostgrestResponse` types from Supabase client
   - Avoid using `any` types for Supabase results
   - Type all database columns and responses properly

3. **Implement consistent error handling**:
   - Always check for errors in Supabase responses before accessing data
   - Handle potential undefined values from database queries
   - Use null coalescing and optional chaining for safer access

4. **Follow existing patterns**:
   - Use the same connection and transaction patterns as existing services
   - Maintain consistent error handling approaches
   - Leverage existing utility functions for database operations

## Conclusion

This technical specification provides a comprehensive guide for implementing script management functionality. By following these steps and guidelines, the implementation will:

1. Reuse existing CLI services for maximum efficiency
2. Implement TypeScript with strict type checking and comprehensive error handling
3. Add thorough validation and verification at each step
4. Create a reliable, maintainable system for script management
5. Avoid TypeScript and Supabase errors through proper implementation practices

The final implementation will integrate seamlessly with the existing codebase, follow all established patterns and best practices, and provide robust script management functionality.

**Remember: Always verify TypeScript compilation and study existing services to avoid common Supabase-related errors.**