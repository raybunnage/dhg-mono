[{"schema_name":"public","function_name":"handle_new_user","parameters":"","return_type":"trigger","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- Add debug logging\n    RAISE NOTICE 'Creating profile for user: %', NEW.id;\n    \n    -- Check if profile already exists\n    IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN\n        RAISE NOTICE 'Profile already exists for user: %', NEW.id;\n        RETURN NEW;\n    END IF;\n\n    -- Attempt to create profile\n    BEGIN\n        INSERT INTO public.profiles (id, email)\n        VALUES (NEW.id, NEW.email);\n        RAISE NOTICE 'Profile created successfully for user: %', NEW.id;\n    EXCEPTION WHEN OTHERS THEN\n        -- Log the error details\n        RAISE NOTICE 'Error creating profile: % %', SQLERRM, SQLSTATE;\n        RETURN NULL; -- This will abort the transaction\n    END;\n\n    RETURN NEW;\nEND;\n$function$\n","trigger_count":1,"used_by_tables":["auth.users"],"bound_triggers":["on_auth_user_created"],"usage_status":"ACTIVE","usage_score":160},{"schema_name":"public","function_name":"update_processing_timestamps","parameters":"","return_type":"trigger","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.update_processing_timestamps()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF NEW.processing_status = 'queued' AND OLD.processing_status != 'queued' THEN\n    NEW.queued_at = NOW();\n  ELSIF NEW.processing_status = 'processing' AND OLD.processing_status != 'processing' THEN\n    NEW.processing_started_at = NOW();\n  ELSIF NEW.processing_status = 'completed' AND OLD.processing_status != 'completed' THEN\n    NEW.processing_completed_at = NOW();\n  ELSIF NEW.processing_status = 'failed' AND OLD.processing_status != 'failed' THEN\n    NEW.last_error_at = NOW();\n    NEW.retry_count = COALESCE(OLD.retry_count, 0) + 1;\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n","trigger_count":1,"used_by_tables":["expert_documents"],"bound_triggers":["expert_documents_status_timestamps"],"usage_status":"ACTIVE","usage_score":130},{"schema_name":"public","function_name":"validate_user_references","parameters":"","return_type":"trigger","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.validate_user_references()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Check if updated_by is a valid user ID\n  IF NEW.updated_by IS NOT NULL AND \n     NOT EXISTS (SELECT 1 FROM auth.users WHERE id = NEW.updated_by) THEN\n    -- Set to NULL if invalid\n    NEW.updated_by = NULL;\n  END IF;\n  \n  -- Check created_by too if your table has it\n  IF NEW.created_by IS NOT NULL AND \n     NOT EXISTS (SELECT 1 FROM auth.users WHERE id = NEW.created_by) THEN\n    -- You might want different logic here, like using a default system user\n    -- or raising an exception\n    NEW.created_by = NULL;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n","trigger_count":1,"used_by_tables":["sources_google"],"bound_triggers":["validate_sources_google_users"],"usage_status":"ACTIVE","usage_score":130},{"schema_name":"public","function_name":"check_user_id_foreign_keys","parameters":"","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.check_user_id_foreign_keys()\n RETURNS TABLE(table_name text, has_user_id boolean, has_proper_fk boolean, constraint_name text, deletion_rule text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    WITH tables_with_user_id AS (\n        SELECT \n            t.table_schema || '.' || t.table_name as table_name,\n            true as has_user_id\n        FROM information_schema.columns c\n        JOIN information_schema.tables t \n            ON c.table_name = t.table_name \n            AND c.table_schema = t.table_schema\n        WHERE c.column_name = 'user_id'\n        AND t.table_schema = 'public'\n    ),\n    foreign_keys AS (\n        SELECT \n            tc.table_schema || '.' || tc.table_name as table_name,\n            tc.constraint_name::text,\n            rc.delete_rule::text\n        FROM information_schema.table_constraints tc\n        JOIN information_schema.key_column_usage kcu \n            ON tc.constraint_name = kcu.constraint_name\n        JOIN information_schema.referential_constraints rc \n            ON tc.constraint_name = rc.constraint_name\n        WHERE kcu.column_name = 'user_id'\n        AND tc.constraint_type = 'FOREIGN KEY'\n    )\n    SELECT \n        t.table_name,\n        true as has_user_id,\n        COALESCE(fk.constraint_name IS NOT NULL, false) as has_proper_fk,\n        COALESCE(fk.constraint_name, 'No Foreign Key')::text as constraint_name,\n        COALESCE(fk.delete_rule, 'No Rule')::text as deletion_rule\n    FROM tables_with_user_id t\n    LEFT JOIN foreign_keys fk ON t.table_name = fk.table_name;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"find_mp4_files_in_folder","parameters":"folder_id text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.find_mp4_files_in_folder(folder_id text)\n RETURNS TABLE(file_id uuid, file_name text, file_drive_id text, file_web_view_link text, parent_folder_name text, parent_folder_drive_id text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    WITH RECURSIVE folder_tree AS (\n        -- Get all direct MP4 files in the specified folder\n        SELECT \n            sg.id,\n            sg.name,\n            sg.drive_id,\n            sg.web_view_link,\n            p.name as parent_name,\n            p.drive_id as parent_drive_id\n        FROM sources_google sg\n        LEFT JOIN sources_google p ON sg.parent_folder_id = p.drive_id\n        WHERE sg.parent_folder_id = folder_id\n        AND sg.mime_type LIKE '%mp4'\n        \n        UNION ALL\n        \n        -- Recursively search subfolders\n        SELECT \n            sg.id,\n            sg.name,\n            sg.drive_id,\n            sg.web_view_link,\n            p.name,\n            p.drive_id\n        FROM sources_google sg\n        INNER JOIN folder_tree ft ON sg.parent_folder_id = ft.drive_id\n        LEFT JOIN sources_google p ON sg.parent_folder_id = p.drive_id\n        WHERE sg.mime_type LIKE '%mp4'\n    )\n    SELECT * FROM folder_tree;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"find_orphaned_user_ids","parameters":"","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.find_orphaned_user_ids()\n RETURNS TABLE(table_name text, column_name text, orphaned_user_id uuid, row_count bigint)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    FOR table_name, column_name IN\n        SELECT t.table_schema || '.' || t.table_name, c.column_name\n        FROM information_schema.columns c\n        JOIN information_schema.tables t \n            ON c.table_name = t.table_name \n            AND c.table_schema = t.table_schema\n        WHERE c.column_name = 'user_id'\n        AND t.table_schema = 'public'\n    LOOP\n        RETURN QUERY EXECUTE format(\n            'SELECT %L::text, %L::text, user_id::uuid, COUNT(*)::bigint ' ||\n            'FROM %s ' ||\n            'WHERE user_id IS NOT NULL ' ||\n            'AND NOT EXISTS (SELECT 1 FROM auth.users WHERE id = user_id) ' ||\n            'GROUP BY user_id',\n            table_name,\n            column_name,\n            table_name\n        );\n    END LOOP;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_all_foreign_keys","parameters":"","return_type":"json","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_all_foreign_keys()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  return (\n    select json_object_agg(\n      source_table,\n      foreign_keys\n    )\n    from (\n      select \n        tc.table_name as source_table,\n        json_agg(\n          json_build_object(\n            'constraint_name', tc.constraint_name,\n            'column_name', kcu.column_name,\n            'foreign_table', ccu.table_name,\n            'foreign_column', ccu.column_name,\n            'on_update', rc.update_rule,\n            'on_delete', rc.delete_rule\n          ) order by kcu.column_name\n        ) as foreign_keys\n      from information_schema.table_constraints tc\n      join information_schema.key_column_usage kcu\n        on tc.constraint_name = kcu.constraint_name\n        and tc.table_schema = kcu.table_schema\n      join information_schema.constraint_column_usage ccu\n        on ccu.constraint_name = tc.constraint_name\n        and ccu.table_schema = tc.table_schema\n      join information_schema.referential_constraints rc\n        on tc.constraint_name = rc.constraint_name\n      where tc.constraint_type = 'FOREIGN KEY'\n        and tc.table_schema = 'public'\n      group by tc.table_name\n    ) fk_info\n  );\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_all_table_definitions","parameters":"","return_type":"SETOF text","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_all_table_definitions()\n RETURNS TABLE(create_statement text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT 'CREATE TABLE ' || tablename || ' (' || string_agg(column_definition, ', ' ORDER BY ordinal_position) || ');'\n    FROM (\n        SELECT\n            t.tablename,\n            c.ordinal_position,\n            c.column_name || ' ' || c.data_type || \n            CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END || \n            CASE WHEN c.is_nullable = 'NO' THEN ' NOT NULL' ELSE '' END || \n            CASE WHEN c.column_default IS NOT NULL THEN ' DEFAULT ' || c.column_default ELSE '' END as column_definition\n        FROM pg_catalog.pg_tables t\n        JOIN information_schema.columns c ON t.tablename = c.table_name\n        WHERE t.schemaname = 'public'\n    ) subquery\n    GROUP BY tablename;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_document_type_counts","parameters":"","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_document_type_counts()\n RETURNS TABLE(mime_type text, count bigint)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    COALESCE(sources_google.mime_type, 'unknown') as mime_type,\n    COUNT(*) as count\n  FROM \n    sources_google\n  WHERE \n    deleted = false\n  GROUP BY \n    sources_google.mime_type\n  ORDER BY \n    count DESC;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_domain_id_by_name","parameters":"domain_name_input text","return_type":"uuid","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_domain_id_by_name(domain_name_input text)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    domain_id uuid;\nBEGIN\n    SELECT id INTO domain_id\n    FROM domains\n    WHERE name = domain_name_input;\n\n    RETURN domain_id;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_dynamic_healing_domain_id","parameters":"","return_type":"uuid","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_dynamic_healing_domain_id()\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN (SELECT id FROM domains WHERE name = 'Dynamic Healing Group' LIMIT 1);\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_foreign_key_info","parameters":"p_constraint_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_foreign_key_info(p_constraint_name text)\n RETURNS TABLE(table_schema text, constraint_name text, table_name text, column_name text, foreign_table_schema text, foreign_table_name text, foreign_column_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        tc.table_schema::text, \n        tc.constraint_name::text, \n        tc.table_name::text, \n        kcu.column_name::text, \n        ccu.table_schema::text AS foreign_table_schema,\n        ccu.table_name::text AS foreign_table_name,\n        ccu.column_name::text AS foreign_column_name \n    FROM \n        information_schema.table_constraints AS tc \n        JOIN information_schema.key_column_usage AS kcu\n          ON tc.constraint_name = kcu.constraint_name\n          AND tc.table_schema = kcu.table_schema\n        JOIN information_schema.constraint_column_usage AS ccu\n          ON ccu.constraint_name = tc.constraint_name\n          AND ccu.table_schema = tc.table_schema\n    WHERE tc.constraint_name = p_constraint_name;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_foreign_keys","parameters":"schema_name text","return_type":"json","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_foreign_keys(schema_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  return (\n    select json_object_agg(\n      tc.table_name,\n      json_agg(\n        json_build_object(\n          'column_name', kcu.column_name,\n          'foreign_table', ccu.table_name,\n          'foreign_column', ccu.column_name\n        )\n      )\n    )\n    from information_schema.table_constraints tc\n    join information_schema.key_column_usage kcu \n      on tc.constraint_name = kcu.constraint_name\n    join information_schema.constraint_column_usage ccu \n      on tc.constraint_name = ccu.constraint_name\n    where tc.constraint_type = 'FOREIGN KEY'\n      and tc.table_schema = schema_name\n    group by tc.table_name\n  );\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_function_details","parameters":"p_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_function_details(p_name text)\n RETURNS TABLE(function_details jsonb, relationships jsonb, history jsonb)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    to_jsonb(f.*) - 'id' as function_details,\n    COALESCE(\n      (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'related_function', fr2.name,\n            'relationship_type', fr.relationship_type,\n            'details', fr.details\n          )\n        )\n        FROM function_relationships fr\n        JOIN function_registry fr2 ON fr.target_function_id = fr2.id\n        WHERE fr.source_function_id = f.id\n      ),\n      '[]'::jsonb\n    ) as relationships,\n    COALESCE(\n      (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'change_type', h.change_type,\n            'changed_at', h.changed_at,\n            'changed_by', h.changed_by,\n            'previous_state', h.previous_state,\n            'new_state', h.new_state,\n            'git_commit_hash', h.git_commit_hash\n          )\n          ORDER BY h.changed_at DESC\n        )\n        FROM function_registry_history h\n        WHERE h.function_id = f.id\n      ),\n      '[]'::jsonb\n    ) as history\n  FROM function_registry f\n  WHERE f.name = p_name;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_functions","parameters":"schema_name text","return_type":"json","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_functions(schema_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  return (\n    select json_agg(\n      json_build_object(\n        'function_name', p.proname,\n        'definition', pg_get_functiondef(p.oid)\n      )\n    )\n    from pg_proc p\n    join pg_namespace n on p.pronamespace = n.oid\n    where n.nspname = schema_name\n  );\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_schema_info","parameters":"schema_name text","return_type":"json","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_schema_info(schema_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  return (\n    select json_object_agg(\n      t.table_name,\n      json_build_object(\n        'columns', (\n          select json_agg(\n            json_build_object(\n              'column_name', c.column_name,\n              'data_type', c.data_type,\n              'is_nullable', c.is_nullable,\n              'column_default', c.column_default\n            )\n          )\n          from information_schema.columns c\n          where c.table_name = t.table_name\n            and c.table_schema = schema_name\n        )\n      )\n    )\n    from information_schema.tables t\n    where t.table_schema = schema_name\n      and t.table_type = 'BASE TABLE'\n  );\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_table_columns","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_columns(p_table_name text)\n RETURNS TABLE(column_name text, data_type text, is_nullable text, column_default text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name,\n        c.data_type,\n        c.is_nullable,\n        c.column_default\n    FROM information_schema.columns c\n    WHERE c.table_schema = 'public'\n    AND c.table_name = p_table_name;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_table_columns_plus","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_columns_plus(p_table_name text)\n RETURNS TABLE(ordinal_position integer, column_name text, data_type text, is_nullable text, column_default text, is_unique text, unique_constraint_name text, foreign_key text, trigger_name text, check_constraint text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    WITH base_columns AS (\n        SELECT DISTINCT\n            c.ordinal_position::integer,\n            c.column_name,\n            c.data_type,\n            c.is_nullable,\n            c.column_default\n        FROM \n            information_schema.columns c\n        WHERE \n            c.table_schema = 'public' \n            AND c.table_name = p_table_name\n    ),\n    unique_constraints AS (\n        SELECT DISTINCT\n            kcu.column_name,\n            'YES' as is_unique,\n            tc.constraint_name as unique_constraint_name\n        FROM \n            information_schema.key_column_usage kcu \n        JOIN \n            information_schema.table_constraints tc \n            ON kcu.constraint_name = tc.constraint_name \n            AND kcu.table_schema = tc.table_schema\n        WHERE \n            kcu.table_schema = 'public' \n            AND kcu.table_name = p_table_name\n            AND tc.constraint_type IN ('UNIQUE', 'PRIMARY KEY')\n    ),\n    foreign_keys AS (\n        SELECT DISTINCT\n            kcu.column_name,\n            fk.constraint_name as foreign_key\n        FROM \n            information_schema.key_column_usage kcu \n        JOIN \n            information_schema.table_constraints tc \n            ON kcu.constraint_name = tc.constraint_name \n        JOIN \n            information_schema.referential_constraints rc \n            ON tc.constraint_name = rc.constraint_name \n        JOIN \n            information_schema.table_constraints fk \n            ON rc.unique_constraint_name = fk.constraint_name \n        WHERE \n            kcu.table_schema = 'public' \n            AND kcu.table_name = p_table_name\n    ),\n    triggers AS (\n        SELECT DISTINCT\n            t.tgname as table_trigger_name\n        FROM \n            pg_trigger t \n        WHERE \n            t.tgrelid = (SELECT oid FROM pg_class WHERE relname = p_table_name AND relnamespace = 'public'::regnamespace)\n    ),\n    check_constraints AS (\n        SELECT \n            conname AS constraint_name,\n            pg_get_constraintdef(oid) AS constraint_definition\n        FROM \n            pg_constraint\n        WHERE \n            conrelid = (p_table_name::regclass)\n            AND contype = 'c'\n    ),\n    combined_checks AS (\n        SELECT string_agg(\n            constraint_name || ': ' || constraint_definition, \n            '; '\n        ) as all_checks\n        FROM check_constraints\n    )\n    SELECT \n        bc.ordinal_position,\n        bc.column_name::text,\n        bc.data_type::text,\n        bc.is_nullable::text,\n        bc.column_default::text,\n        COALESCE(uc.is_unique, 'NO')::text as is_unique,\n        uc.unique_constraint_name::text,\n        fk.foreign_key::text,\n        (SELECT table_trigger_name::text FROM triggers LIMIT 1) as trigger_name,\n        (SELECT all_checks FROM combined_checks)::text as check_constraint\n    FROM \n        base_columns bc\n        LEFT JOIN unique_constraints uc ON bc.column_name = uc.column_name\n        LEFT JOIN foreign_keys fk ON bc.column_name = fk.column_name\n    ORDER BY \n        bc.ordinal_position;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_table_columns_with_constraints_and_triggers","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_columns_with_constraints_and_triggers(p_table_name text)\n RETURNS TABLE(column_name text, data_type text, is_nullable text, column_default text, is_unique text, foreign_key text, trigger_name text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name::text, \n        c.data_type::text, \n        c.is_nullable::text, \n        c.column_default::text,\n        CASE \n            WHEN kcu.column_name IS NOT NULL THEN 'YES' \n            ELSE 'NO' \n        END AS is_unique,\n        fk.constraint_name AS foreign_key,\n        t.tgname AS trigger_name\n    FROM \n        information_schema.columns c\n    LEFT JOIN \n        information_schema.key_column_usage kcu \n        ON c.table_name = kcu.table_name \n        AND c.column_name = kcu.column_name \n        AND c.table_schema = kcu.table_schema\n    LEFT JOIN \n        information_schema.table_constraints tc \n        ON kcu.constraint_name = tc.constraint_name \n        AND kcu.table_schema = tc.table_schema\n    LEFT JOIN \n        information_schema.referential_constraints rc \n        ON tc.constraint_name = rc.constraint_name \n        AND tc.table_schema = rc.constraint_schema\n    LEFT JOIN \n        information_schema.table_constraints fk \n        ON rc.unique_constraint_name = fk.constraint_name \n        AND rc.unique_constraint_schema = fk.table_schema\n    LEFT JOIN \n        pg_trigger t \n        ON t.tgrelid = (SELECT oid FROM pg_class WHERE relname = p_table_name AND relnamespace = 'public'::regnamespace)\n    WHERE \n        c.table_schema = 'public' \n        AND c.table_name = p_table_name;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_table_columns_with_unique","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_columns_with_unique(p_table_name text)\n RETURNS TABLE(column_name text, data_type text, is_nullable text, column_default text, is_unique text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name::text, \n        c.data_type::text, \n        c.is_nullable::text, \n        c.column_default::text,\n        CASE \n            WHEN kcu.column_name IS NOT NULL THEN 'YES' \n            ELSE 'NO' \n        END AS is_unique\n    FROM \n        information_schema.columns c\n    LEFT JOIN \n        information_schema.key_column_usage kcu \n        ON c.table_name = kcu.table_name \n        AND c.column_name = kcu.column_name \n        AND c.table_schema = kcu.table_schema\n    LEFT JOIN \n        information_schema.table_constraints tc \n        ON kcu.constraint_name = tc.constraint_name \n        AND kcu.table_schema = tc.table_schema\n    WHERE \n        c.table_schema = 'public' \n        AND c.table_name = p_table_name;\n        -- AND tc.constraint_type = 'UNIQUE';\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_table_constraints","parameters":"p_table_name text","return_type":"json","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_constraints(p_table_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    result json;\nBEGIN\n    WITH constraints AS (\n        -- Get NOT NULL constraints\n        SELECT \n            'not_null' as constraint_type,\n            column_name,\n            NULL as constraint_definition\n        FROM information_schema.columns \n        WHERE table_name = p_table_name \n        AND is_nullable = 'NO'\n        \n        UNION ALL\n        \n        -- Get CHECK constraints\n        SELECT \n            'check' as constraint_type,\n            pga.attname as column_name,\n            pg_get_constraintdef(pgc.oid) as constraint_definition\n        FROM pg_constraint pgc\n        JOIN pg_namespace nsp ON nsp.oid = pgc.connamespace\n        JOIN pg_class cls ON pgc.conrelid = cls.oid\n        LEFT JOIN pg_attribute pga ON pga.attrelid = pgc.conrelid \n            AND pga.attnum = ANY(pgc.conkey)\n        WHERE cls.relname = p_table_name\n        AND pgc.contype = 'c'\n    )\n    SELECT json_build_object(\n        'not_null', (\n            SELECT json_agg(column_name)\n            FROM constraints \n            WHERE constraint_type = 'not_null'\n        ),\n        'check', (\n            SELECT json_agg(\n                json_build_object(\n                    'column', column_name,\n                    'constraint', constraint_definition\n                )\n            )\n            FROM constraints \n            WHERE constraint_type = 'check'\n        )\n    ) INTO result;\n    \n    RETURN result;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_table_definition","parameters":"p_table_name text","return_type":"SETOF text","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_definition(p_table_name text)\n RETURNS SETOF text\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        'CREATE TABLE ' || tablename || ' (' ||\n        string_agg(column_definition, ', ' ORDER BY ordinal_position) ||\n        ');'\n    FROM (\n        SELECT\n            t.tablename,\n            c.ordinal_position,\n            c.column_name || ' ' || c.data_type ||\n            CASE WHEN c.character_maximum_length IS NOT NULL\n                 THEN '(' || c.character_maximum_length || ')'\n                 ELSE ''\n            END ||\n            CASE WHEN c.is_nullable = 'NO' THEN ' NOT NULL' ELSE '' END ||\n            CASE WHEN c.column_default IS NOT NULL\n                 THEN ' DEFAULT ' || c.column_default\n                 ELSE ''\n            END as column_definition\n        FROM pg_catalog.pg_tables t\n        JOIN information_schema.columns c\n             ON t.tablename = c.table_name\n        WHERE t.schemaname = 'public'\n        AND t.tablename = p_table_name\n    ) subquery\n    GROUP BY tablename;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"get_table_foreign_keys","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_foreign_keys(p_table_name text)\n RETURNS TABLE(table_schema text, constraint_name text, table_name text, column_name text, foreign_table_schema text, foreign_table_name text, foreign_column_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        tc.table_schema::text, \n        tc.constraint_name::text, \n        tc.table_name::text, \n        kcu.column_name::text, \n        ccu.table_schema::text AS foreign_table_schema,\n        ccu.table_name::text AS foreign_table_name,\n        ccu.column_name::text AS foreign_column_name \n    FROM \n        information_schema.table_constraints AS tc \n        JOIN information_schema.key_column_usage AS kcu\n          ON tc.constraint_name = kcu.constraint_name\n          AND tc.table_schema = kcu.table_schema\n        JOIN information_schema.constraint_column_usage AS ccu\n          ON ccu.constraint_name = tc.constraint_name\n          AND ccu.table_schema = tc.table_schema\n    WHERE tc.table_name = p_table_name\n    AND tc.constraint_type = 'FOREIGN KEY';\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_table_info","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":true,"description":"Gets table information including column names, nullability, data types, and check constraints","owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_info(p_table_name text)\n RETURNS TABLE(column_name text, is_nullable text, data_type text, check_constraint text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    return query\n    select \n        c.column_name::text,\n        c.is_nullable::text,\n        c.data_type::text,\n        cc.check_clause::text as check_constraint\n    from information_schema.columns c\n    left join information_schema.constraint_column_usage ccu \n        on ccu.table_name = c.table_name \n        and ccu.column_name = c.column_name\n    left join information_schema.check_constraints cc\n        on cc.constraint_name = ccu.constraint_name\n    where c.table_name = p_table_name\n    and c.table_schema = 'public';\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_table_metadata","parameters":"p_target_table text","return_type":"jsonb","volatility":"VOLATILE","is_security_definer":true,"description":"Returns detailed metadata about the specified database table, including columns, constraints, indexes, triggers, and RLS policies.","owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_table_metadata(p_target_table text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result jsonb;\nBEGIN\n  -- Get basic table information\n  WITH table_info AS (\n    SELECT \n      c.relname AS table_name,\n      obj_description(c.oid) AS table_description,\n      pg_size_pretty(pg_total_relation_size(c.oid)) AS table_size,\n      pg_total_relation_size(c.oid) AS table_size_bytes,\n      (SELECT COUNT(*) FROM pg_stat_user_tables WHERE relname = c.relname) > 0 AS is_user_table,\n      to_char(GREATEST(\n        (SELECT max(last_vacuum) FROM pg_stat_user_tables WHERE relname = c.relname),\n        (SELECT max(last_autovacuum) FROM pg_stat_user_tables WHERE relname = c.relname)\n      ), 'YYYY-MM-DD HH24:MI:SS') AS last_vacuum,\n      to_char(GREATEST(\n        (SELECT max(last_analyze) FROM pg_stat_user_tables WHERE relname = c.relname),\n        (SELECT max(last_autoanalyze) FROM pg_stat_user_tables WHERE relname = c.relname)\n      ), 'YYYY-MM-DD HH24:MI:SS') AS last_analyze,\n      (SELECT count(*) FROM pg_stat_user_tables WHERE relname = c.relname) AS row_count\n    FROM pg_class c\n    WHERE c.relname = p_target_table AND c.relkind = 'r'\n  ),\n  \n  -- Get columns information\n  columns AS (\n    SELECT \n      a.attname AS column_name,\n      pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,\n      CASE \n        WHEN a.attnotnull THEN true\n        ELSE false\n      END AS is_not_null,\n      CASE \n        WHEN (SELECT COUNT(*) FROM pg_constraint\n              WHERE conrelid = a.attrelid\n              AND conkey[1] = a.attnum\n              AND contype = 'p') > 0 THEN true\n        ELSE false\n      END AS is_primary_key,\n      CASE \n        WHEN a.atthasdef THEN pg_get_expr(d.adbin, d.adrelid)\n        ELSE NULL\n      END AS default_value,\n      col_description(a.attrelid, a.attnum) AS column_description,\n      a.attnum AS ordinal_position\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef d ON a.attrelid = d.adrelid AND a.attnum = d.adnum\n    WHERE a.attrelid = p_target_table::regclass\n    AND a.attnum > 0\n    AND NOT a.attisdropped\n    ORDER BY a.attnum\n  ),\n  \n  -- Get constraint information\n  constraints AS (\n    SELECT\n      con.conname AS constraint_name,\n      con.contype AS constraint_type,\n      CASE\n        WHEN con.contype = 'p' THEN 'PRIMARY KEY'\n        WHEN con.contype = 'u' THEN 'UNIQUE'\n        WHEN con.contype = 'f' THEN 'FOREIGN KEY'\n        WHEN con.contype = 'c' THEN 'CHECK'\n        ELSE con.contype::text\n      END AS constraint_type_desc,\n      pg_get_constraintdef(con.oid) AS constraint_definition,\n      con.conkey AS constraint_columns,\n      con.confrelid::regclass::text AS referenced_table,\n      con.confkey AS referenced_columns\n    FROM pg_constraint con\n    JOIN pg_class rel ON rel.oid = con.conrelid\n    WHERE rel.relname = p_target_table\n  ),\n  \n  -- Get index information\n  indexes AS (\n    SELECT\n      i.relname AS index_name,\n      am.amname AS index_type,\n      pg_get_indexdef(i.oid) AS index_definition,\n      idx.indisunique AS is_unique,\n      idx.indisprimary AS is_primary,\n      idx.indisexclusion AS is_exclusion,\n      idx.indimmediate AS is_immediate,\n      idx.indisclustered AS is_clustered,\n      idx.indisvalid AS is_valid,\n      array_to_string(array_agg(a.attname), ', ') AS index_columns\n    FROM pg_index idx\n    JOIN pg_class i ON i.oid = idx.indexrelid\n    JOIN pg_class t ON t.oid = idx.indrelid\n    JOIN pg_am am ON am.oid = i.relam\n    JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(idx.indkey)\n    WHERE t.relname = p_target_table\n    GROUP BY i.relname, am.amname, idx.indisunique, idx.indisprimary, \n             idx.indisexclusion, idx.indimmediate, idx.indisclustered, \n             idx.indisvalid, i.oid\n  ),\n  \n  -- Get trigger information\n  triggers AS (\n    SELECT\n      trg.tgname AS trigger_name,\n      pg_get_triggerdef(trg.oid) AS trigger_definition,\n      CASE \n        WHEN trg.tgenabled = 'O' THEN 'ENABLED'\n        WHEN trg.tgenabled = 'D' THEN 'DISABLED'\n        WHEN trg.tgenabled = 'R' THEN 'REPLICA'\n        WHEN trg.tgenabled = 'A' THEN 'ALWAYS'\n        ELSE trg.tgenabled::text\n      END AS trigger_status\n    FROM pg_trigger trg\n    JOIN pg_class tbl ON tbl.oid = trg.tgrelid\n    WHERE NOT trg.tgisinternal\n    AND tbl.relname = p_target_table\n  ),\n  \n  -- Get foreign key information\n  foreign_keys AS (\n    SELECT\n      con.conname AS fk_name,\n      src_table.relname AS source_table,\n      src_att.attname AS source_column,\n      tgt_table.relname AS target_table,\n      tgt_att.attname AS target_column,\n      CASE con.confupdtype\n        WHEN 'a' THEN 'NO ACTION'\n        WHEN 'r' THEN 'RESTRICT'\n        WHEN 'c' THEN 'CASCADE'\n        WHEN 'n' THEN 'SET NULL'\n        WHEN 'd' THEN 'SET DEFAULT'\n        ELSE 'UNKNOWN'\n      END AS on_update,\n      CASE con.confdeltype\n        WHEN 'a' THEN 'NO ACTION'\n        WHEN 'r' THEN 'RESTRICT'\n        WHEN 'c' THEN 'CASCADE'\n        WHEN 'n' THEN 'SET NULL'\n        WHEN 'd' THEN 'SET DEFAULT'\n        ELSE 'UNKNOWN'\n      END AS on_delete\n    FROM pg_constraint con\n    JOIN pg_class src_table ON src_table.oid = con.conrelid\n    JOIN pg_class tgt_table ON tgt_table.oid = con.confrelid\n    JOIN pg_attribute src_att ON src_att.attrelid = con.conrelid AND src_att.attnum = con.conkey[1]\n    JOIN pg_attribute tgt_att ON tgt_att.attrelid = con.confrelid AND tgt_att.attnum = con.confkey[1]\n    WHERE con.contype = 'f'\n    AND (src_table.relname = p_target_table OR tgt_table.relname = p_target_table)\n  ),\n  \n  -- Get RLS policies\n  rls_policies AS (\n    SELECT\n      pol.polname AS policy_name,\n      pol.polcmd AS command,\n      CASE pol.polcmd\n        WHEN 'r' THEN 'SELECT'\n        WHEN 'a' THEN 'INSERT'\n        WHEN 'w' THEN 'UPDATE'\n        WHEN 'd' THEN 'DELETE'\n        WHEN '*' THEN 'ALL'\n        ELSE 'UNKNOWN'\n      END AS command_desc,\n      pol.polpermissive AS is_permissive,\n      pg_get_expr(pol.polqual, pol.polrelid) AS using_expression,\n      pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check_expression,\n      array_to_string(ARRAY(\n        SELECT rolname FROM pg_roles WHERE oid = ANY(pol.polroles)\n      ), ', ') AS roles\n    FROM pg_policy pol\n    JOIN pg_class tbl ON tbl.oid = pol.polrelid\n    WHERE tbl.relname = p_target_table\n  )\n  \n  -- Combine all information into a JSON object\n  SELECT jsonb_build_object(\n    'table_info', (\n      SELECT row_to_json(ti) FROM table_info ti\n    ),\n    'columns', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', column_name,\n          'type', data_type,\n          'not_null', is_not_null,\n          'is_primary_key', is_primary_key,\n          'default', default_value,\n          'description', column_description,\n          'position', ordinal_position\n        )\n      )\n      FROM columns\n    ),\n    'constraints', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', constraint_name,\n          'type', constraint_type,\n          'type_desc', constraint_type_desc,\n          'definition', constraint_definition,\n          'columns', constraint_columns,\n          'referenced_table', referenced_table,\n          'referenced_columns', referenced_columns\n        )\n      )\n      FROM constraints\n    ),\n    'indexes', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', index_name,\n          'type', index_type,\n          'definition', index_definition,\n          'is_unique', is_unique,\n          'is_primary', is_primary,\n          'columns', index_columns\n        )\n      )\n      FROM indexes\n    ),\n    'triggers', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', trigger_name,\n          'definition', trigger_definition,\n          'status', trigger_status\n        )\n      )\n      FROM triggers\n    ),\n    'foreign_keys', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', fk_name,\n          'source_table', source_table,\n          'source_column', source_column,\n          'target_table', target_table,\n          'target_column', target_column,\n          'on_update', on_update,\n          'on_delete', on_delete\n        )\n      )\n      FROM foreign_keys\n    ),\n    'rls_policies', (\n      SELECT jsonb_agg(\n        jsonb_build_object(\n          'name', policy_name,\n          'command', command,\n          'command_desc', command_desc,\n          'is_permissive', is_permissive,\n          'using_expression', using_expression,\n          'with_check_expression', with_check_expression,\n          'roles', roles\n        )\n      )\n      FROM rls_policies\n    ),\n    'metadata_generated_at', now()\n  ) INTO result;\n\n  RETURN result;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_triggers","parameters":"schema_name text","return_type":"json","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_triggers(schema_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  return (\n    select json_agg(\n      json_build_object(\n        'trigger_name', trigger_name,\n        'event_manipulation', event_manipulation,\n        'event_object_table', event_object_table,\n        'action_statement', action_statement\n      )\n    )\n    from information_schema.triggers\n    where trigger_schema = schema_name\n  );\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":60},{"schema_name":"public","function_name":"get_user_uuid_by_email","parameters":"email_input text","return_type":"uuid","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.get_user_uuid_by_email(email_input text)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    user_uuid uuid;\nBEGIN\n    SELECT id INTO user_uuid\n    FROM auth.users\n    WHERE email = email_input;\n\n    RETURN user_uuid;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"LIKELY USED","usage_score":30},{"schema_name":"public","function_name":"add_unique_constraint","parameters":"p_table_name text, p_column_name text","return_type":"void","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.add_unique_constraint(p_table_name text, p_column_name text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    constraint_name text;\n    constraint_exists boolean;\nBEGIN\n    -- Generate a unique constraint name based on the table and column names\n    constraint_name := format('uq_%I_%I', p_table_name, p_column_name);\n\n    -- Check if the unique constraint already exists\n    SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.table_constraints tc\n        JOIN information_schema.key_column_usage kcu \n            ON tc.constraint_name = kcu.constraint_name \n            AND tc.table_schema = kcu.table_schema\n        WHERE \n            tc.table_name = p_table_name \n            AND kcu.column_name = p_column_name \n            AND tc.constraint_type = 'UNIQUE'\n    ) INTO constraint_exists;\n\n    IF constraint_exists THEN\n        RAISE NOTICE 'Unique constraint % already exists on table % for column %', constraint_name, p_table_name, p_column_name;\n        RETURN;  -- Exit the function if the constraint already exists\n    END IF;\n\n    -- Execute the command to add the unique constraint\n    EXECUTE format('ALTER TABLE %I ADD CONSTRAINT %I UNIQUE (%I)', \n                   p_table_name, \n                   constraint_name, \n                   p_column_name);\n    \n    RAISE NOTICE 'Unique constraint % added to table % on column %', constraint_name, p_table_name, p_column_name;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"admin_fix_audio_processing_configs","parameters":"","return_type":"void","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.admin_fix_audio_processing_configs()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  default_user_id UUID := 'f5972054-059e-4b1e-915e-268bcdcc94b9';\nBEGIN\n  -- 1. Add updated_by column if missing\n  IF NOT EXISTS (\n    SELECT 1 FROM information_schema.columns \n    WHERE table_schema = 'public' \n      AND table_name = 'audio_processing_configs' \n      AND column_name = 'updated_by'\n  ) THEN\n    -- Add the column\n    ALTER TABLE public.audio_processing_configs ADD COLUMN updated_by UUID;\n    \n    -- Update existing rows with system user ID\n    UPDATE public.audio_processing_configs\n    SET updated_by = default_user_id\n    WHERE updated_by IS NULL;\n    \n    -- Make it NOT NULL\n    ALTER TABLE public.audio_processing_configs ALTER COLUMN updated_by SET NOT NULL;\n    \n    RAISE NOTICE 'Added updated_by column to audio_processing_configs';\n  ELSE\n    RAISE NOTICE 'updated_by column already exists on audio_processing_configs';\n  END IF;\n\n  -- 2. Add configuration validation constraint if not exists\n  IF NOT EXISTS (\n    SELECT 1 FROM information_schema.table_constraints\n    WHERE constraint_name = 'valid_audio_processing_config'\n      AND table_name = 'audio_processing_configs'\n  ) THEN\n    ALTER TABLE public.audio_processing_configs\n    ADD CONSTRAINT valid_audio_processing_config\n    CHECK (\n      -- Basic structure checks\n      configuration IS NOT NULL\n      AND jsonb_typeof(configuration) = 'object'\n      \n      -- Support both camelCase and snake_case keys\n      AND (\n        (configuration ? 'processor_type' OR configuration ? 'processorType')\n        AND \n        (configuration ? 'parameters')\n      )\n      \n      -- Parameters must be an object\n      AND jsonb_typeof(\n        CASE \n          WHEN configuration ? 'parameters' THEN configuration->'parameters'\n          ELSE NULL::jsonb\n        END\n      ) = 'object'\n      \n      -- Type-specific validation with support for both naming conventions\n      AND (\n        -- Transcription processors\n        (\n          (configuration->>'processor_type' = 'transcription' OR configuration->>'processorType' = 'transcription')\n          AND (\n            jsonb_path_exists(configuration, '$.parameters.model') OR\n            jsonb_path_exists(configuration, '$.parameters.language')\n          )\n        )\n        OR\n        -- Diarization processors\n        (\n          (configuration->>'processor_type' = 'diarization' OR configuration->>'processorType' = 'diarization')\n          AND (\n            jsonb_path_exists(configuration, '$.parameters.speaker_count') OR\n            jsonb_path_exists(configuration, '$.parameters.speakerCount')\n          )\n        )\n        OR\n        -- Audio extraction processors\n        (\n          (configuration->>'processor_type' = 'audio_extraction' OR configuration->>'processorType' = 'audio_extraction')\n          AND (\n            jsonb_path_exists(configuration, '$.parameters.format') OR\n            jsonb_path_exists(configuration, '$.parameters.fileFormat')\n          )\n        )\n        OR\n        -- Allow other processor types defined in the batch_type enum\n        (\n          (configuration->>'processor_type' IN ('google_extraction', 'summarization') OR \n           configuration->>'processorType' IN ('google_extraction', 'summarization'))\n        )\n        OR\n        -- Allow future processor types with minimal validation\n        (\n          (configuration->>'processor_type' NOT IN ('transcription', 'diarization', 'audio_extraction', 'summarization', 'google_extraction') AND\n           configuration->>'processorType' NOT IN ('transcription', 'diarization', 'audio_extraction', 'summarization', 'google_extraction'))\n        )\n      )\n    );\n    \n    RAISE NOTICE 'Added configuration validation constraint to audio_processing_configs';\n  ELSE\n    RAISE NOTICE 'Configuration validation constraint already exists on audio_processing_configs';\n  END IF;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":60},{"schema_name":"public","function_name":"analyze_default_values","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.analyze_default_values(p_table_name text)\n RETURNS TABLE(column_name text, data_type text, current_default text, suggested_default text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        a.attname,\n        pg_catalog.format_type(a.atttypid, a.atttypmod) as data_type,\n        COALESCE(pg_get_expr(d.adbin, d.adrelid), '') as current_default,\n        CASE \n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE '%timestamp%' \n                THEN 'CURRENT_TIMESTAMP'\n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) = 'boolean' \n                THEN 'false'\n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) = 'integer' \n                THEN '0'\n            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) = 'text' \n                THEN ''''\n            ELSE 'No suggestion'\n        END as suggested_default\n    FROM pg_attribute a\n    LEFT JOIN pg_attrdef d ON a.attrelid = d.adrelid AND a.attnum = d.adnum\n    JOIN pg_class t ON a.attrelid = t.oid\n    WHERE t.relname = p_table_name \n    AND a.attnum > 0 \n    AND NOT a.attisdropped;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"analyze_foreign_keys","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.analyze_foreign_keys(p_table_name text)\n RETURNS TABLE(column_name text, potential_reference_table text, potential_reference_column text, match_percentage numeric)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    WITH column_values AS (\n        SELECT \n            a.attname as column_name,\n            t2.relname as ref_table,\n            a2.attname as ref_column,\n            count(distinct c1.value) as distinct_values,\n            count(distinct c2.value) as matching_values\n        FROM pg_attribute a\n        JOIN pg_class t ON a.attrelid = t.oid\n        CROSS JOIN pg_class t2\n        JOIN pg_attribute a2 ON a2.attrelid = t2.oid\n        LEFT JOIN LATERAL (\n            SELECT DISTINCT cast(value as text) as value \n            FROM (SELECT (unnest(array_agg(row_to_json->>a.attname)))::text as value \n                  FROM (SELECT row_to_json(t) FROM ONLY pg_catalog.pg_class WHERE relname = p_table_name) x) y\n        ) c1 ON true\n        LEFT JOIN LATERAL (\n            SELECT DISTINCT cast(value as text) as value \n            FROM (SELECT (unnest(array_agg(row_to_json->>a2.attname)))::text as value \n                  FROM (SELECT row_to_json(t2) FROM ONLY pg_catalog.pg_class WHERE relname = t2.relname) x) y\n        ) c2 ON c1.value = c2.value\n        WHERE t.relname = p_table_name \n        AND t2.relname != p_table_name\n        AND a.attnum > 0 \n        AND a2.attnum > 0\n        AND NOT a.attisdropped\n        AND NOT a2.attisdropped\n        GROUP BY a.attname, t2.relname, a2.attname\n        HAVING count(distinct c1.value) > 0\n    )\n    SELECT \n        column_name,\n        ref_table,\n        ref_column,\n        (matching_values::numeric / distinct_values::numeric) * 100 as match_percentage\n    FROM column_values\n    WHERE matching_values::numeric / distinct_values::numeric > 0.8\n    ORDER BY match_percentage DESC;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"analyze_table_constraints","parameters":"p_table_name text","return_type":"text","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.analyze_table_constraints(p_table_name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    report text := '';\n    unique_rec record;\nBEGIN\n    -- Initialize report\n    report := 'Table Analysis Report for ' || p_table_name || E'\\n\\n';\n    \n    -- Unique constraints analysis\n    report := report || 'Potential Unique Constraints:' || E'\\n';\n    FOR unique_rec IN SELECT * FROM analyze_unique_constraints(p_table_name) LOOP\n        report := report || format('  Column: %s (Distinct ratio: %s%%) - %s', \n            unique_rec.column_name, \n            round(unique_rec.distinct_ratio * 100, 2)::text, \n            unique_rec.recommendation) || E'\\n';\n    END LOOP;\n    \n    RETURN report;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"analyze_unique_constraints","parameters":"p_table_name text","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.analyze_unique_constraints(p_table_name text)\n RETURNS TABLE(column_name text, distinct_ratio numeric, recommendation text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    WITH column_stats AS (\n        SELECT \n            a.attname,\n            pg_stats.n_distinct,\n            pg_stats.null_frac,\n            (SELECT count(*) FROM pg_catalog.pg_class c WHERE c.relname = p_table_name) as total_rows\n        FROM pg_attribute a\n        JOIN pg_class t ON a.attrelid = t.oid\n        LEFT JOIN pg_stats ON t.relname = pg_stats.tablename AND a.attname = pg_stats.attname\n        WHERE t.relname = p_table_name AND a.attnum > 0 AND NOT a.attisdropped\n    )\n    SELECT \n        attname::text,\n        COALESCE(\n            CASE \n                WHEN n_distinct < 0 THEN abs(n_distinct)\n                WHEN n_distinct > 0 THEN n_distinct / total_rows::numeric\n                ELSE 0\n            END,\n            0\n        )::numeric,\n        (CASE \n            WHEN n_distinct < 0 AND abs(n_distinct) > 0.95 THEN 'Highly recommended for UNIQUE constraint'\n            WHEN n_distinct > 0 AND (n_distinct / total_rows::numeric) > 0.95 THEN 'Consider UNIQUE constraint'\n            ELSE 'Not recommended for UNIQUE constraint'\n        END)::text\n    FROM column_stats;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"export_functions_audit","parameters":"","return_type":"json","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.export_functions_audit()\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  all_functions json;\nBEGIN\n  -- Get basic function information in a simple SQL statement\n  CREATE TEMP TABLE function_data AS\n  SELECT \n    n.nspname AS schema_name,\n    p.proname AS function_name,\n    pg_get_function_arguments(p.oid) AS parameters,\n    CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END || \n      pg_catalog.format_type(p.prorettype, NULL) AS return_type,\n    CASE p.provolatile\n      WHEN 'i' THEN 'IMMUTABLE'\n      WHEN 's' THEN 'STABLE'\n      WHEN 'v' THEN 'VOLATILE'\n    END AS volatility,\n    p.prosecdef AS is_security_definer,\n    obj_description(p.oid, 'pg_proc') AS description,\n    p.proowner::regrole::text AS owner,\n    COALESCE(pg_stat_get_function_calls(p.oid), 0) AS call_count,\n    COALESCE(round(pg_stat_get_function_total_time(p.oid)::numeric, 2), 0) AS total_time_ms,\n    pg_get_functiondef(p.oid) AS full_definition\n  FROM \n    pg_proc p\n  JOIN \n    pg_namespace n ON p.pronamespace = n.oid\n  WHERE \n    n.nspname = 'public';\n\n  -- Add trigger info in a separate step\n  ALTER TABLE function_data ADD COLUMN trigger_count int DEFAULT 0;\n  ALTER TABLE function_data ADD COLUMN used_by_tables text[] DEFAULT '{}';\n  ALTER TABLE function_data ADD COLUMN bound_triggers text[] DEFAULT '{}';\n  \n  -- Update with trigger info\n  WITH trigger_data AS (\n    SELECT \n      p.proname AS function_name,\n      COUNT(*) AS trigger_count,\n      array_agg(DISTINCT t.tgrelid::regclass::text) AS tables,\n      array_agg(DISTINCT t.tgname::text) AS trigger_names\n    FROM \n      pg_trigger t\n    JOIN \n      pg_proc p ON t.tgfoid = p.oid\n    WHERE \n      p.pronamespace = 'public'::regnamespace\n    GROUP BY \n      p.proname\n  )\n  UPDATE function_data fd\n  SET \n    trigger_count = td.trigger_count,\n    used_by_tables = td.tables,\n    bound_triggers = td.trigger_names\n  FROM \n    trigger_data td\n  WHERE \n    fd.function_name = td.function_name;\n    \n  -- Add usage status and score\n  ALTER TABLE function_data ADD COLUMN usage_status text;\n  ALTER TABLE function_data ADD COLUMN usage_score int;\n  \n  UPDATE function_data\n  SET \n    usage_status = \n      CASE \n        WHEN call_count > 100 OR trigger_count > 0 THEN 'ACTIVE'\n        WHEN call_count > 0 THEN 'USED'\n        WHEN function_name LIKE '%get_%' OR \n             function_name LIKE '%find_%' OR\n             function_name LIKE '%check_%' OR\n             function_name LIKE '%validate_%' THEN 'LIKELY USED'\n        ELSE 'POTENTIALLY UNUSED'\n      END,\n    usage_score = \n      CASE WHEN call_count > 0 THEN 100 ELSE 0 END +\n      CASE WHEN trigger_count > 0 THEN 100 ELSE 0 END +\n      CASE WHEN is_security_definer THEN 30 ELSE 0 END +\n      CASE WHEN volatility = 'IMMUTABLE' THEN 10 \n           WHEN volatility = 'STABLE' THEN 20\n           ELSE 30 END;\n  \n  -- Get the final JSON result\n  SELECT json_agg(row_to_json(fd))\n  INTO all_functions\n  FROM (\n    SELECT * FROM function_data\n    ORDER BY \n      CASE \n        WHEN usage_status = 'ACTIVE' THEN 3\n        WHEN usage_status = 'USED' THEN 2\n        WHEN usage_status = 'LIKELY USED' THEN 1\n        ELSE 0\n      END DESC, \n      function_name\n  ) fd;\n  \n  -- Clean up\n  DROP TABLE function_data;\n  \n  RETURN all_functions;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"fix_expert_documents_nulls","parameters":"","return_type":"void","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.fix_expert_documents_nulls()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  UPDATE public.expert_documents \n  SET updated_by = 'f5972054-059e-4b1e-915e-268bcdcc94b9'::uuid \n  WHERE updated_by IS NULL;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"generate_table_documentation","parameters":"p_table_name text","return_type":"text","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.generate_table_documentation(p_table_name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    field_info text := '';\n    constraint_info text := '';\n    foreign_key_info text := '';\n    trigger_info text := '';\n    sql text;\n    field RECORD;  -- Declare field as RECORD\n    constr RECORD;  -- Renamed from constraint to constr\n    fk RECORD;  -- Declare foreign key as RECORD\n    trigger RECORD;  -- Declare trigger as RECORD\nBEGIN\n    -- Gather field information\n    sql := format('SELECT column_name, data_type, is_nullable, column_default \n                   FROM information_schema.columns \n                   WHERE table_name = %L', p_table_name);\n    FOR field IN EXECUTE sql LOOP\n        field_info := field_info || format('Field: %s, Type: %s, Nullable: %s, Default: %s%s',\n            field.column_name, field.data_type, field.is_nullable, COALESCE(field.column_default, 'None'), E'\\n');\n    END LOOP;\n\n    -- Gather constraint information\n    sql := format('SELECT conname, contype \n                   FROM pg_constraint \n                   WHERE conrelid = %L::regclass', p_table_name);\n    FOR constr IN EXECUTE sql LOOP\n        constraint_info := constraint_info || format('Constraint: %s, Type: %s%s',\n            constr.conname, \n            CASE constr.contype\n                WHEN 'p' THEN 'Primary Key'\n                WHEN 'u' THEN 'Unique'\n                WHEN 'f' THEN 'Foreign Key'\n                WHEN 'c' THEN 'Check'\n                ELSE 'Other'\n            END, E'\\n');\n    END LOOP;\n\n    -- Gather foreign key information\n    sql := format('SELECT conname, confrelid::regclass AS referenced_table \n                   FROM pg_constraint \n                   WHERE conrelid = %L::regclass AND contype = ''f''', p_table_name);\n    FOR fk IN EXECUTE sql LOOP\n        foreign_key_info := foreign_key_info || format('Foreign Key: %s, References: %s%s',\n            fk.conname, fk.referenced_table, E'\\n');\n    END LOOP;\n\n    -- Gather trigger information\n    sql := format('SELECT tgname \n                   FROM pg_trigger \n                   WHERE tgrelid = %L::regclass', p_table_name);\n    FOR trigger IN EXECUTE sql LOOP\n        trigger_info := trigger_info || format('Trigger: %s%s', trigger.tgname, E'\\n');\n    END LOOP;\n\n    -- Combine all information\n    RETURN 'Fields:\\n' || field_info || \n           'Constraints:\\n' || constraint_info || \n           'Foreign Keys:\\n' || foreign_key_info || \n           'Triggers:\\n' || trigger_info;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"generate_unique_constraints_sql","parameters":"p_table_name text","return_type":"text","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.generate_unique_constraints_sql(p_table_name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    unique_rec RECORD;\n    sql_statements text := '';\nBEGIN\n    -- Loop through the unique constraints analysis\n    FOR unique_rec IN SELECT * FROM analyze_unique_constraints(p_table_name) LOOP\n        IF unique_rec.recommendation LIKE 'Highly recommended for UNIQUE constraint' OR\n           unique_rec.recommendation LIKE 'Consider UNIQUE constraint' THEN\n            sql_statements := sql_statements || format('ALTER TABLE %I ADD CONSTRAINT unique_%I UNIQUE (%I);%s', \n                p_table_name, \n                unique_rec.column_name, \n                unique_rec.column_name, \n                E'\\n');\n        END IF;\n    END LOOP;\n\n    -- Return the generated SQL statements\n    RETURN sql_statements;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"handle_timestamps","parameters":"","return_type":"trigger","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.handle_timestamps()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF (TG_OP = 'INSERT') THEN\n    NEW.created_at = NOW();\n    NEW.updated_at = NOW();\n  ELSIF (TG_OP = 'UPDATE') THEN\n    NEW.updated_at = NOW();\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"list_function_comments","parameters":"","return_type":"SETOF record","volatility":"VOLATILE","is_security_definer":true,"description":"Lists all public functions with their comments, schema, return types, and arguments","owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.list_function_comments()\n RETURNS TABLE(function_name text, comment_text text, schema_name text, return_type text, argument_types text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    return query\n    SELECT \n        p.proname::text as function_name,\n        d.description::text as comment_text,\n        n.nspname::text as schema_name,\n        t.typname::text as return_type,\n        pg_get_function_arguments(p.oid)::text as argument_types\n    FROM \n        pg_proc p\n        LEFT JOIN pg_description d ON p.oid = d.objoid\n        LEFT JOIN pg_namespace n ON p.pronamespace = n.oid\n        LEFT JOIN pg_type t ON p.prorettype = t.oid\n    WHERE \n        n.nspname = 'public'\n    ORDER BY \n        p.proname;\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":60},{"schema_name":"public","function_name":"populate_sources_with_fixed_user_id","parameters":"user_email_address text","return_type":"void","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.populate_sources_with_fixed_user_id(user_email_address text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    user_id uuid;\nBEGIN\n    -- Get the domain_id using the provided domain name\n    user_id := get_user_uuid_by_email(user_email_address);\n\n    -- Insert a new record into the sources table\n    INSERT INTO public.sources (\n        user_id\n    ) VALUES (\n        user_id\n    );\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"set_current_domain","parameters":"domain_id uuid","return_type":"void","volatility":"VOLATILE","is_security_definer":true,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.set_current_domain(domain_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nbegin\n  -- Set the domain_id in the session\n  perform set_config('app.current_domain_id', domain_id::text, false);\nend;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":60},{"schema_name":"public","function_name":"table_exists","parameters":"p_schema_name text, p_table_name text","return_type":"boolean","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.table_exists(p_schema_name text, p_table_name text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  exists_val boolean;\nBEGIN\n  SELECT EXISTS (\n    SELECT FROM information_schema.tables \n    WHERE table_schema = p_schema_name AND table_name = p_table_name\n  ) INTO exists_val;\n  RETURN exists_val;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"transfer_temp_experts_to_experts","parameters":"","return_type":"void","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.transfer_temp_experts_to_experts()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO public.experts (expert_name, full_name, starting_ref_id, is_in_core_group, created_by, updated_by, domain_id, user_id)\n  SELECT \n    expert_name, \n    full_name, \n    starting_ref_id, \n    is_in_core_group, \n    'f5972054-059e-4b1e-915e-268bcdcc94b9', \n    'f5972054-059e-4b1e-915e-268bcdcc94b9', \n    '752f3bf7-a392-4283-bd32-e3f0e530c205', \n    'f5972054-059e-4b1e-915e-268bcdcc94b9'\n  FROM public.temp_experts;\n\n  -- Optionally, you can clear the temp_experts table after transfer\n  -- DELETE FROM public.temp_experts;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30},{"schema_name":"public","function_name":"update_search_vector","parameters":"","return_type":"trigger","volatility":"VOLATILE","is_security_definer":false,"description":null,"owner":"postgres","call_count":0,"total_time_ms":0,"full_definition":"CREATE OR REPLACE FUNCTION public.update_search_vector()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.search_vector := to_tsvector('english', coalesce(NEW.content, '') || ' ' || coalesce(NEW.subject, ''));\n    RETURN NEW;\nEND;\n$function$\n","trigger_count":0,"used_by_tables":[],"bound_triggers":[],"usage_status":"POTENTIALLY UNUSED","usage_score":30}]